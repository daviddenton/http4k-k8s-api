package http4k.k8s.client

import http4k.k8s.model.io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration
import http4k.k8s.model.io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList
import http4k.k8s.model.io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration
import http4k.k8s.model.io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList
import http4k.k8s.model.io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicy
import http4k.k8s.model.io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBinding
import http4k.k8s.model.io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingList
import http4k.k8s.model.io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyList
import http4k.k8s.model.io.k8s.api.apiserverinternal.v1alpha1.StorageVersion
import http4k.k8s.model.io.k8s.api.apiserverinternal.v1alpha1.StorageVersionList
import http4k.k8s.model.io.k8s.api.apps.v1.ControllerRevision
import http4k.k8s.model.io.k8s.api.apps.v1.ControllerRevisionList
import http4k.k8s.model.io.k8s.api.apps.v1.DaemonSet
import http4k.k8s.model.io.k8s.api.apps.v1.DaemonSetList
import http4k.k8s.model.io.k8s.api.apps.v1.Deployment
import http4k.k8s.model.io.k8s.api.apps.v1.DeploymentList
import http4k.k8s.model.io.k8s.api.apps.v1.ReplicaSet
import http4k.k8s.model.io.k8s.api.apps.v1.ReplicaSetList
import http4k.k8s.model.io.k8s.api.apps.v1.StatefulSet
import http4k.k8s.model.io.k8s.api.apps.v1.StatefulSetList
import http4k.k8s.model.io.k8s.api.authentication.v1.TokenRequest
import http4k.k8s.model.io.k8s.api.authentication.v1.TokenReview
import http4k.k8s.model.io.k8s.api.authentication.v1alpha1.SelfSubjectReview
import http4k.k8s.model.io.k8s.api.authorization.v1.LocalSubjectAccessReview
import http4k.k8s.model.io.k8s.api.authorization.v1.SelfSubjectAccessReview
import http4k.k8s.model.io.k8s.api.authorization.v1.SelfSubjectRulesReview
import http4k.k8s.model.io.k8s.api.authorization.v1.SubjectAccessReview
import http4k.k8s.model.io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler
import http4k.k8s.model.io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerList
import http4k.k8s.model.io.k8s.api.autoscaling.v1.Scale
import http4k.k8s.model.io.k8s.api.batch.v1.CronJob
import http4k.k8s.model.io.k8s.api.batch.v1.CronJobList
import http4k.k8s.model.io.k8s.api.batch.v1.Job
import http4k.k8s.model.io.k8s.api.batch.v1.JobList
import http4k.k8s.model.io.k8s.api.certificates.v1.CertificateSigningRequest
import http4k.k8s.model.io.k8s.api.certificates.v1.CertificateSigningRequestList
import http4k.k8s.model.io.k8s.api.coordination.v1.Lease
import http4k.k8s.model.io.k8s.api.coordination.v1.LeaseList
import http4k.k8s.model.io.k8s.api.core.v1.Binding
import http4k.k8s.model.io.k8s.api.core.v1.ComponentStatus
import http4k.k8s.model.io.k8s.api.core.v1.ComponentStatusList
import http4k.k8s.model.io.k8s.api.core.v1.ConfigMap
import http4k.k8s.model.io.k8s.api.core.v1.ConfigMapList
import http4k.k8s.model.io.k8s.api.core.v1.Endpoints
import http4k.k8s.model.io.k8s.api.core.v1.EndpointsList
import http4k.k8s.model.io.k8s.api.core.v1.Event
import http4k.k8s.model.io.k8s.api.core.v1.EventList
import http4k.k8s.model.io.k8s.api.core.v1.LimitRange
import http4k.k8s.model.io.k8s.api.core.v1.LimitRangeList
import http4k.k8s.model.io.k8s.api.core.v1.Namespace
import http4k.k8s.model.io.k8s.api.core.v1.NamespaceList
import http4k.k8s.model.io.k8s.api.core.v1.Node
import http4k.k8s.model.io.k8s.api.core.v1.NodeList
import http4k.k8s.model.io.k8s.api.core.v1.PersistentVolume
import http4k.k8s.model.io.k8s.api.core.v1.PersistentVolumeClaim
import http4k.k8s.model.io.k8s.api.core.v1.PersistentVolumeClaimList
import http4k.k8s.model.io.k8s.api.core.v1.PersistentVolumeList
import http4k.k8s.model.io.k8s.api.core.v1.Pod
import http4k.k8s.model.io.k8s.api.core.v1.PodList
import http4k.k8s.model.io.k8s.api.core.v1.PodTemplate
import http4k.k8s.model.io.k8s.api.core.v1.PodTemplateList
import http4k.k8s.model.io.k8s.api.core.v1.ReplicationController
import http4k.k8s.model.io.k8s.api.core.v1.ReplicationControllerList
import http4k.k8s.model.io.k8s.api.core.v1.ResourceQuota
import http4k.k8s.model.io.k8s.api.core.v1.ResourceQuotaList
import http4k.k8s.model.io.k8s.api.core.v1.Secret
import http4k.k8s.model.io.k8s.api.core.v1.SecretList
import http4k.k8s.model.io.k8s.api.core.v1.Service
import http4k.k8s.model.io.k8s.api.core.v1.ServiceAccount
import http4k.k8s.model.io.k8s.api.core.v1.ServiceAccountList
import http4k.k8s.model.io.k8s.api.core.v1.ServiceList
import http4k.k8s.model.io.k8s.api.discovery.v1.EndpointSlice
import http4k.k8s.model.io.k8s.api.discovery.v1.EndpointSliceList
import http4k.k8s.model.io.k8s.api.flowcontrol.v1beta2.FlowSchema
import http4k.k8s.model.io.k8s.api.flowcontrol.v1beta2.FlowSchemaList
import http4k.k8s.model.io.k8s.api.flowcontrol.v1beta2.PriorityLevelConfiguration
import http4k.k8s.model.io.k8s.api.flowcontrol.v1beta2.PriorityLevelConfigurationList
import http4k.k8s.model.io.k8s.api.networking.v1.Ingress
import http4k.k8s.model.io.k8s.api.networking.v1.IngressClass
import http4k.k8s.model.io.k8s.api.networking.v1.IngressClassList
import http4k.k8s.model.io.k8s.api.networking.v1.IngressList
import http4k.k8s.model.io.k8s.api.networking.v1.NetworkPolicy
import http4k.k8s.model.io.k8s.api.networking.v1.NetworkPolicyList
import http4k.k8s.model.io.k8s.api.networking.v1alpha1.ClusterCIDR
import http4k.k8s.model.io.k8s.api.networking.v1alpha1.ClusterCIDRList
import http4k.k8s.model.io.k8s.api.node.v1.RuntimeClass
import http4k.k8s.model.io.k8s.api.node.v1.RuntimeClassList
import http4k.k8s.model.io.k8s.api.policy.v1.Eviction
import http4k.k8s.model.io.k8s.api.policy.v1.PodDisruptionBudget
import http4k.k8s.model.io.k8s.api.policy.v1.PodDisruptionBudgetList
import http4k.k8s.model.io.k8s.api.rbac.v1.ClusterRole
import http4k.k8s.model.io.k8s.api.rbac.v1.ClusterRoleBinding
import http4k.k8s.model.io.k8s.api.rbac.v1.ClusterRoleBindingList
import http4k.k8s.model.io.k8s.api.rbac.v1.ClusterRoleList
import http4k.k8s.model.io.k8s.api.rbac.v1.Role
import http4k.k8s.model.io.k8s.api.rbac.v1.RoleBinding
import http4k.k8s.model.io.k8s.api.rbac.v1.RoleBindingList
import http4k.k8s.model.io.k8s.api.rbac.v1.RoleList
import http4k.k8s.model.io.k8s.api.resource.v1alpha1.PodScheduling
import http4k.k8s.model.io.k8s.api.resource.v1alpha1.PodSchedulingList
import http4k.k8s.model.io.k8s.api.resource.v1alpha1.ResourceClaim
import http4k.k8s.model.io.k8s.api.resource.v1alpha1.ResourceClaimList
import http4k.k8s.model.io.k8s.api.resource.v1alpha1.ResourceClaimTemplate
import http4k.k8s.model.io.k8s.api.resource.v1alpha1.ResourceClaimTemplateList
import http4k.k8s.model.io.k8s.api.resource.v1alpha1.ResourceClass
import http4k.k8s.model.io.k8s.api.resource.v1alpha1.ResourceClassList
import http4k.k8s.model.io.k8s.api.scheduling.v1.PriorityClass
import http4k.k8s.model.io.k8s.api.scheduling.v1.PriorityClassList
import http4k.k8s.model.io.k8s.api.storage.v1.CSIDriver
import http4k.k8s.model.io.k8s.api.storage.v1.CSIDriverList
import http4k.k8s.model.io.k8s.api.storage.v1.CSINode
import http4k.k8s.model.io.k8s.api.storage.v1.CSINodeList
import http4k.k8s.model.io.k8s.api.storage.v1.CSIStorageCapacity
import http4k.k8s.model.io.k8s.api.storage.v1.CSIStorageCapacityList
import http4k.k8s.model.io.k8s.api.storage.v1.StorageClass
import http4k.k8s.model.io.k8s.api.storage.v1.StorageClassList
import http4k.k8s.model.io.k8s.api.storage.v1.VolumeAttachment
import http4k.k8s.model.io.k8s.api.storage.v1.VolumeAttachmentList
import http4k.k8s.model.io.k8s.apiextensions.apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinition
import http4k.k8s.model.io.k8s.apiextensions.apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionList
import http4k.k8s.model.io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup
import http4k.k8s.model.io.k8s.apimachinery.pkg.apis.meta.v1.APIGroupList
import http4k.k8s.model.io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList
import http4k.k8s.model.io.k8s.apimachinery.pkg.apis.meta.v1.APIVersions
import http4k.k8s.model.io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions
import http4k.k8s.model.io.k8s.apimachinery.pkg.apis.meta.v1.Patch
import http4k.k8s.model.io.k8s.apimachinery.pkg.apis.meta.v1.Status
import http4k.k8s.model.io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent
import http4k.k8s.model.io.k8s.apimachinery.pkg.version.Info
import http4k.k8s.model.io.k8s.kube.aggregator.pkg.apis.apiregistration.v1.APIService
import http4k.k8s.model.io.k8s.kube.aggregator.pkg.apis.apiregistration.v1.APIServiceList
import org.http4k.core.Body
import org.http4k.core.Filter
import org.http4k.core.HttpHandler
import org.http4k.core.Method
import org.http4k.core.Request
import org.http4k.core.then
import org.http4k.core.with
import org.http4k.filter.ClientFilters
import org.http4k.format.Jackson.auto
import org.http4k.lens.Header
import org.http4k.lens.Path
import org.http4k.lens.Query
import org.http4k.lens.boolean
import org.http4k.lens.int
import org.http4k.lens.string

class KubernetesClient(
    private val httpHandler: HttpHandler
) {
    private val bearerToken: Filter =
        ClientFilters.ApiKeyAuth(Header.required("authorization") of "<insert api key>")

    /**
     * get service account issuer OpenID configuration, also known as the 'OIDC discovery doc'
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getServiceAccountIssuerOpenIDConfiguration(): String {
        val getServiceAccountIssuerOpenIDConfigurationJsonResponse200Lens = Body.auto<String>().toLens()
        val httpReq = Request(Method.GET, "/.well-known/openid-configuration/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return getServiceAccountIssuerOpenIDConfigurationJsonResponse200Lens(response)
    }

    /**
     * get available API versions
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getCoreAPIVersions(): APIVersions {
        val iok8sapimachinerypkgapismetav1APIVersionsLens = Body.auto<APIVersions>().toLens()
        val httpReq = Request(Method.GET, "/api/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIVersionsLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getCoreV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/api/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * list objects of kind ComponentStatus
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1ComponentStatus(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ComponentStatusList {
        val iok8sapicorev1ComponentStatusListLens = Body.auto<ComponentStatusList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/componentstatuses")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ComponentStatusListLens(response)
    }

    /**
     * read the specified ComponentStatus
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1ComponentStatus(name: String, pretty: String? = null): ComponentStatus {
        val iok8sapicorev1ComponentStatusLens = Body.auto<ComponentStatus>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/componentstatuses/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ComponentStatusLens(response)
    }

    /**
     * list or watch objects of kind ConfigMap
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1ConfigMapForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ConfigMapList {
        val iok8sapicorev1ConfigMapListLens = Body.auto<ConfigMapList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/configmaps")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ConfigMapListLens(response)
    }

    /**
     * list or watch objects of kind Endpoints
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1EndpointsForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): EndpointsList {
        val iok8sapicorev1EndpointsListLens = Body.auto<EndpointsList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/endpoints")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EndpointsListLens(response)
    }

    /**
     * list or watch objects of kind Event
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1EventForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): EventList {
        val iok8sapicorev1EventListLens = Body.auto<EventList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/events")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EventListLens(response)
    }

    /**
     * list or watch objects of kind LimitRange
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1LimitRangeForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): LimitRangeList {
        val iok8sapicorev1LimitRangeListLens = Body.auto<LimitRangeList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/limitranges")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1LimitRangeListLens(response)
    }

    /**
     * list or watch objects of kind Namespace
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1Namespace(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): NamespaceList {
        val iok8sapicorev1NamespaceListLens = Body.auto<NamespaceList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NamespaceListLens(response)
    }

    /**
     * create a Namespace
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1Namespace(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Namespace: Namespace
    ): Namespace {
        val iok8sapicorev1NamespaceLens = Body.auto<Namespace>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces")
            .with(iok8sapicorev1NamespaceLens of iok8sapicorev1Namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NamespaceLens(response)
    }

    /**
     * create a Binding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedBinding(
        namespace: String,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapicorev1Binding: Binding
    ): Binding {
        val iok8sapicorev1BindingLens = Body.auto<Binding>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/bindings")
            .with(iok8sapicorev1BindingLens of iok8sapicorev1Binding)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1BindingLens(response)
    }

    /**
     * delete collection of ConfigMap
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedConfigMap(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/configmaps")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ConfigMap
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedConfigMap(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ConfigMapList {
        val iok8sapicorev1ConfigMapListLens = Body.auto<ConfigMapList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/configmaps")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ConfigMapListLens(response)
    }

    /**
     * create a ConfigMap
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedConfigMap(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ConfigMap: ConfigMap
    ): ConfigMap {
        val iok8sapicorev1ConfigMapLens = Body.auto<ConfigMap>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/configmaps")
            .with(iok8sapicorev1ConfigMapLens of iok8sapicorev1ConfigMap)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ConfigMapLens(response)
    }

    /**
     * delete a ConfigMap
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedConfigMap(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/configmaps/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ConfigMap
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedConfigMap(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ConfigMap {
        val iok8sapicorev1ConfigMapLens = Body.auto<ConfigMap>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/configmaps/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ConfigMapLens(response)
    }

    /**
     * partially update the specified ConfigMap
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedConfigMap(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ConfigMap {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1ConfigMapLens = Body.auto<ConfigMap>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/configmaps/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ConfigMapLens(response)
    }

    /**
     * replace the specified ConfigMap
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedConfigMap(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ConfigMap: ConfigMap
    ): ConfigMap {
        val iok8sapicorev1ConfigMapLens = Body.auto<ConfigMap>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/configmaps/{name}")
            .with(iok8sapicorev1ConfigMapLens of iok8sapicorev1ConfigMap)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ConfigMapLens(response)
    }

    /**
     * delete collection of Endpoints
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedEndpoints(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/endpoints")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Endpoints
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedEndpoints(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): EndpointsList {
        val iok8sapicorev1EndpointsListLens = Body.auto<EndpointsList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/endpoints")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EndpointsListLens(response)
    }

    /**
     * create Endpoints
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedEndpoints(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Endpoints: Endpoints
    ): Endpoints {
        val iok8sapicorev1EndpointsLens = Body.auto<Endpoints>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/endpoints")
            .with(iok8sapicorev1EndpointsLens of iok8sapicorev1Endpoints)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EndpointsLens(response)
    }

    /**
     * delete Endpoints
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedEndpoints(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/endpoints/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Endpoints
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedEndpoints(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Endpoints {
        val iok8sapicorev1EndpointsLens = Body.auto<Endpoints>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/endpoints/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EndpointsLens(response)
    }

    /**
     * partially update the specified Endpoints
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedEndpoints(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Endpoints {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1EndpointsLens = Body.auto<Endpoints>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/endpoints/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EndpointsLens(response)
    }

    /**
     * replace the specified Endpoints
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedEndpoints(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Endpoints: Endpoints
    ): Endpoints {
        val iok8sapicorev1EndpointsLens = Body.auto<Endpoints>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/endpoints/{name}")
            .with(iok8sapicorev1EndpointsLens of iok8sapicorev1Endpoints)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EndpointsLens(response)
    }

    /**
     * delete collection of Event
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedEvent(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/events")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Event
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedEvent(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): EventList {
        val iok8sapicorev1EventListLens = Body.auto<EventList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/events")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EventListLens(response)
    }

    /**
     * create an Event
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedEvent(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Event: Event
    ): Event {
        val iok8sapicorev1EventLens = Body.auto<Event>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/events")
            .with(iok8sapicorev1EventLens of iok8sapicorev1Event)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EventLens(response)
    }

    /**
     * delete an Event
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedEvent(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/events/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Event
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedEvent(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Event {
        val iok8sapicorev1EventLens = Body.auto<Event>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/events/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EventLens(response)
    }

    /**
     * partially update the specified Event
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedEvent(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Event {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1EventLens = Body.auto<Event>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/events/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EventLens(response)
    }

    /**
     * replace the specified Event
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedEvent(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Event: Event
    ): Event {
        val iok8sapicorev1EventLens = Body.auto<Event>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/events/{name}")
            .with(iok8sapicorev1EventLens of iok8sapicorev1Event)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1EventLens(response)
    }

    /**
     * delete collection of LimitRange
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedLimitRange(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/limitranges")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind LimitRange
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedLimitRange(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): LimitRangeList {
        val iok8sapicorev1LimitRangeListLens = Body.auto<LimitRangeList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/limitranges")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1LimitRangeListLens(response)
    }

    /**
     * create a LimitRange
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedLimitRange(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1LimitRange: LimitRange
    ): LimitRange {
        val iok8sapicorev1LimitRangeLens = Body.auto<LimitRange>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/limitranges")
            .with(iok8sapicorev1LimitRangeLens of iok8sapicorev1LimitRange)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1LimitRangeLens(response)
    }

    /**
     * delete a LimitRange
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedLimitRange(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/limitranges/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified LimitRange
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedLimitRange(
        name: String,
        namespace: String,
        pretty: String? = null
    ): LimitRange {
        val iok8sapicorev1LimitRangeLens = Body.auto<LimitRange>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/limitranges/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1LimitRangeLens(response)
    }

    /**
     * partially update the specified LimitRange
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedLimitRange(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): LimitRange {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1LimitRangeLens = Body.auto<LimitRange>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/limitranges/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1LimitRangeLens(response)
    }

    /**
     * replace the specified LimitRange
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedLimitRange(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1LimitRange: LimitRange
    ): LimitRange {
        val iok8sapicorev1LimitRangeLens = Body.auto<LimitRange>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/limitranges/{name}")
            .with(iok8sapicorev1LimitRangeLens of iok8sapicorev1LimitRange)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1LimitRangeLens(response)
    }

    /**
     * delete collection of PersistentVolumeClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedPersistentVolumeClaim(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/persistentvolumeclaims")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedPersistentVolumeClaim(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PersistentVolumeClaimList {
        val iok8sapicorev1PersistentVolumeClaimListLens = Body.auto<PersistentVolumeClaimList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/persistentvolumeclaims")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimListLens(response)
    }

    /**
     * create a PersistentVolumeClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedPersistentVolumeClaim(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1PersistentVolumeClaim: PersistentVolumeClaim
    ): PersistentVolumeClaim {
        val iok8sapicorev1PersistentVolumeClaimLens = Body.auto<PersistentVolumeClaim>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/persistentvolumeclaims")
            .with(iok8sapicorev1PersistentVolumeClaimLens of iok8sapicorev1PersistentVolumeClaim)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimLens(response)
    }

    /**
     * delete a PersistentVolumeClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedPersistentVolumeClaim(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): PersistentVolumeClaim {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapicorev1PersistentVolumeClaimLens = Body.auto<PersistentVolumeClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimLens(response)
    }

    /**
     * read the specified PersistentVolumeClaim
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedPersistentVolumeClaim(
        name: String,
        namespace: String,
        pretty: String? = null
    ): PersistentVolumeClaim {
        val iok8sapicorev1PersistentVolumeClaimLens = Body.auto<PersistentVolumeClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimLens(response)
    }

    /**
     * partially update the specified PersistentVolumeClaim
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedPersistentVolumeClaim(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PersistentVolumeClaim {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1PersistentVolumeClaimLens = Body.auto<PersistentVolumeClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimLens(response)
    }

    /**
     * replace the specified PersistentVolumeClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedPersistentVolumeClaim(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1PersistentVolumeClaim: PersistentVolumeClaim
    ): PersistentVolumeClaim {
        val iok8sapicorev1PersistentVolumeClaimLens = Body.auto<PersistentVolumeClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}")
            .with(iok8sapicorev1PersistentVolumeClaimLens of iok8sapicorev1PersistentVolumeClaim)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimLens(response)
    }

    /**
     * read status of the specified PersistentVolumeClaim
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedPersistentVolumeClaimStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): PersistentVolumeClaim {
        val iok8sapicorev1PersistentVolumeClaimLens = Body.auto<PersistentVolumeClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimLens(response)
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedPersistentVolumeClaimStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PersistentVolumeClaim {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1PersistentVolumeClaimLens = Body.auto<PersistentVolumeClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimLens(response)
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedPersistentVolumeClaimStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1PersistentVolumeClaim: PersistentVolumeClaim
    ): PersistentVolumeClaim {
        val iok8sapicorev1PersistentVolumeClaimLens = Body.auto<PersistentVolumeClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status")
            .with(iok8sapicorev1PersistentVolumeClaimLens of iok8sapicorev1PersistentVolumeClaim)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimLens(response)
    }

    /**
     * delete collection of Pod
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedPod(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/pods")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Pod
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedPod(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PodList {
        val iok8sapicorev1PodListLens = Body.auto<PodList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodListLens(response)
    }

    /**
     * create a Pod
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedPod(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Pod: Pod
    ): Pod {
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/pods")
            .with(iok8sapicorev1PodLens of iok8sapicorev1Pod)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * delete a Pod
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedPod(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Pod {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/pods/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * read the specified Pod
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedPod(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Pod {
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * partially update the specified Pod
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedPod(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Pod {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/pods/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * replace the specified Pod
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedPod(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Pod: Pod
    ): Pod {
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/pods/{name}")
            .with(iok8sapicorev1PodLens of iok8sapicorev1Pod)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * connect GET requests to attach of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1GetNamespacedPodAttach(
        name: String,
        namespace: String,
        container: String? = null,
        stderr: Boolean? = null,
        stdin: Boolean? = null,
        stdout: Boolean? = null,
        tty: Boolean? = null
    ): String {
        val connectCoreV1GetNamespacedPodAttachResponse200Lens = Body.auto<String>().toLens()
        val containerLens = Query.string().optional("container")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val stderrLens = Query.boolean().optional("stderr")
        val stdinLens = Query.boolean().optional("stdin")
        val stdoutLens = Query.boolean().optional("stdout")
        val ttyLens = Query.boolean().optional("tty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods/{name}/attach")
            .with(containerLens of container)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(stderrLens of stderr)
            .with(stdinLens of stdin)
            .with(stdoutLens of stdout)
            .with(ttyLens of tty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1GetNamespacedPodAttachResponse200Lens(response)
    }

    /**
     * connect POST requests to attach of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PostNamespacedPodAttach(
        name: String,
        namespace: String,
        container: String? = null,
        stderr: Boolean? = null,
        stdin: Boolean? = null,
        stdout: Boolean? = null,
        tty: Boolean? = null
    ): String {
        val connectCoreV1PostNamespacedPodAttachResponse200Lens = Body.auto<String>().toLens()
        val containerLens = Query.string().optional("container")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val stderrLens = Query.boolean().optional("stderr")
        val stdinLens = Query.boolean().optional("stdin")
        val stdoutLens = Query.boolean().optional("stdout")
        val ttyLens = Query.boolean().optional("tty")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/pods/{name}/attach")
            .with(containerLens of container)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(stderrLens of stderr)
            .with(stdinLens of stdin)
            .with(stdoutLens of stdout)
            .with(ttyLens of tty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PostNamespacedPodAttachResponse200Lens(response)
    }

    /**
     * create binding of a Pod
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedPodBinding(
        name: String,
        namespace: String,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapicorev1Binding: Binding
    ): Binding {
        val iok8sapicorev1BindingLens = Body.auto<Binding>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/pods/{name}/binding")
            .with(iok8sapicorev1BindingLens of iok8sapicorev1Binding)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1BindingLens(response)
    }

    /**
     * read ephemeralcontainers of the specified Pod
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedPodEphemeralcontainers(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Pod {
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * partially update ephemeralcontainers of the specified Pod
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedPodEphemeralcontainers(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Pod {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * replace ephemeralcontainers of the specified Pod
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedPodEphemeralcontainers(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Pod: Pod
    ): Pod {
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers")
            .with(iok8sapicorev1PodLens of iok8sapicorev1Pod)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * create eviction of a Pod
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedPodEviction(
        name: String,
        namespace: String,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapipolicyv1Eviction: Eviction
    ): Eviction {
        val iok8sapipolicyv1EvictionLens = Body.auto<Eviction>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/pods/{name}/eviction")
            .with(iok8sapipolicyv1EvictionLens of iok8sapipolicyv1Eviction)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1EvictionLens(response)
    }

    /**
     * connect GET requests to exec of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1GetNamespacedPodExec(
        name: String,
        namespace: String,
        command: String? = null,
        container: String? = null,
        stderr: Boolean? = null,
        stdin: Boolean? = null,
        stdout: Boolean? = null,
        tty: Boolean? = null
    ): String {
        val connectCoreV1GetNamespacedPodExecResponse200Lens = Body.auto<String>().toLens()
        val commandLens = Query.string().optional("command")
        val containerLens = Query.string().optional("container")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val stderrLens = Query.boolean().optional("stderr")
        val stdinLens = Query.boolean().optional("stdin")
        val stdoutLens = Query.boolean().optional("stdout")
        val ttyLens = Query.boolean().optional("tty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods/{name}/exec")
            .with(commandLens of command)
            .with(containerLens of container)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(stderrLens of stderr)
            .with(stdinLens of stdin)
            .with(stdoutLens of stdout)
            .with(ttyLens of tty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1GetNamespacedPodExecResponse200Lens(response)
    }

    /**
     * connect POST requests to exec of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PostNamespacedPodExec(
        name: String,
        namespace: String,
        command: String? = null,
        container: String? = null,
        stderr: Boolean? = null,
        stdin: Boolean? = null,
        stdout: Boolean? = null,
        tty: Boolean? = null
    ): String {
        val connectCoreV1PostNamespacedPodExecResponse200Lens = Body.auto<String>().toLens()
        val commandLens = Query.string().optional("command")
        val containerLens = Query.string().optional("container")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val stderrLens = Query.boolean().optional("stderr")
        val stdinLens = Query.boolean().optional("stdin")
        val stdoutLens = Query.boolean().optional("stdout")
        val ttyLens = Query.boolean().optional("tty")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/pods/{name}/exec")
            .with(commandLens of command)
            .with(containerLens of container)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(stderrLens of stderr)
            .with(stdinLens of stdin)
            .with(stdoutLens of stdout)
            .with(ttyLens of tty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PostNamespacedPodExecResponse200Lens(response)
    }

    /**
     * read log of the specified Pod
     * Response:
     * 	text/plain
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedPodLog(
        name: String,
        namespace: String,
        container: String? = null,
        follow: Boolean? = null,
        insecureSkipTLSVerifyBackend: Boolean? = null,
        limitBytes: Int? = null,
        pretty: String? = null,
        previous: Boolean? = null,
        sinceSeconds: Int? = null,
        tailLines: Int? = null,
        timestamps: Boolean? = null
    ): String {
        val readCoreV1NamespacedPodLogPlainResponse200Lens = Body.auto<String>().toLens()
        val containerLens = Query.string().optional("container")
        val followLens = Query.boolean().optional("follow")
        val insecureSkipTLSVerifyBackendLens = Query.boolean().optional("insecureSkipTLSVerifyBackend")
        val limitBytesLens = Query.int().optional("limitBytes")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val previousLens = Query.boolean().optional("previous")
        val sinceSecondsLens = Query.int().optional("sinceSeconds")
        val tailLinesLens = Query.int().optional("tailLines")
        val timestampsLens = Query.boolean().optional("timestamps")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods/{name}/log")
            .with(containerLens of container)
            .with(followLens of follow)
            .with(insecureSkipTLSVerifyBackendLens of insecureSkipTLSVerifyBackend)
            .with(limitBytesLens of limitBytes)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(previousLens of previous)
            .with(sinceSecondsLens of sinceSeconds)
            .with(tailLinesLens of tailLines)
            .with(timestampsLens of timestamps)
        val response = bearerToken.then(httpHandler)(httpReq)
        return readCoreV1NamespacedPodLogPlainResponse200Lens(response)
    }

    /**
     * connect GET requests to portforward of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1GetNamespacedPodPortforward(
        name: String,
        namespace: String,
        ports: Int? = null
    ): String {
        val connectCoreV1GetNamespacedPodPortforwardResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val portsLens = Query.int().optional("ports")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods/{name}/portforward")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(portsLens of ports)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1GetNamespacedPodPortforwardResponse200Lens(response)
    }

    /**
     * connect POST requests to portforward of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PostNamespacedPodPortforward(
        name: String,
        namespace: String,
        ports: Int? = null
    ): String {
        val connectCoreV1PostNamespacedPodPortforwardResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val portsLens = Query.int().optional("ports")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/pods/{name}/portforward")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(portsLens of ports)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PostNamespacedPodPortforwardResponse200Lens(response)
    }

    /**
     * connect DELETE requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1DeleteNamespacedPodProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1DeleteNamespacedPodProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/pods/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1DeleteNamespacedPodProxyResponse200Lens(response)
    }

    /**
     * connect GET requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1GetNamespacedPodProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1GetNamespacedPodProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1GetNamespacedPodProxyResponse200Lens(response)
    }

    /**
     * connect HEAD requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1HeadNamespacedPodProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1HeadNamespacedPodProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.HEAD, "/api/v1/namespaces/{namespace}/pods/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1HeadNamespacedPodProxyResponse200Lens(response)
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1OptionsNamespacedPodProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1OptionsNamespacedPodProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.OPTIONS, "/api/v1/namespaces/{namespace}/pods/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1OptionsNamespacedPodProxyResponse200Lens(response)
    }

    /**
     * connect PATCH requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PatchNamespacedPodProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1PatchNamespacedPodProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/pods/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PatchNamespacedPodProxyResponse200Lens(response)
    }

    /**
     * connect POST requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PostNamespacedPodProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1PostNamespacedPodProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/pods/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PostNamespacedPodProxyResponse200Lens(response)
    }

    /**
     * connect PUT requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PutNamespacedPodProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1PutNamespacedPodProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/pods/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PutNamespacedPodProxyResponse200Lens(response)
    }

    /**
     * connect DELETE requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1DeleteNamespacedPodProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1DeleteNamespacedPodProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1DeleteNamespacedPodProxyWithPathResponse200Lens(response)
    }

    /**
     * connect GET requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1GetNamespacedPodProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1GetNamespacedPodProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1GetNamespacedPodProxyWithPathResponse200Lens(response)
    }

    /**
     * connect HEAD requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1HeadNamespacedPodProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1HeadNamespacedPodProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.HEAD, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1HeadNamespacedPodProxyWithPathResponse200Lens(response)
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1OptionsNamespacedPodProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1OptionsNamespacedPodProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.OPTIONS, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1OptionsNamespacedPodProxyWithPathResponse200Lens(response)
    }

    /**
     * connect PATCH requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PatchNamespacedPodProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1PatchNamespacedPodProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PatchNamespacedPodProxyWithPathResponse200Lens(response)
    }

    /**
     * connect POST requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PostNamespacedPodProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1PostNamespacedPodProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PostNamespacedPodProxyWithPathResponse200Lens(response)
    }

    /**
     * connect PUT requests to proxy of Pod
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PutNamespacedPodProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1PutNamespacedPodProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PutNamespacedPodProxyWithPathResponse200Lens(response)
    }

    /**
     * read status of the specified Pod
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedPodStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Pod {
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/pods/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * partially update status of the specified Pod
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedPodStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Pod {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/pods/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * replace status of the specified Pod
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedPodStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Pod: Pod
    ): Pod {
        val iok8sapicorev1PodLens = Body.auto<Pod>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/pods/{name}/status")
            .with(iok8sapicorev1PodLens of iok8sapicorev1Pod)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodLens(response)
    }

    /**
     * delete collection of PodTemplate
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedPodTemplate(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/podtemplates")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind PodTemplate
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedPodTemplate(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PodTemplateList {
        val iok8sapicorev1PodTemplateListLens = Body.auto<PodTemplateList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/podtemplates")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodTemplateListLens(response)
    }

    /**
     * create a PodTemplate
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedPodTemplate(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1PodTemplate: PodTemplate
    ): PodTemplate {
        val iok8sapicorev1PodTemplateLens = Body.auto<PodTemplate>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/podtemplates")
            .with(iok8sapicorev1PodTemplateLens of iok8sapicorev1PodTemplate)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodTemplateLens(response)
    }

    /**
     * delete a PodTemplate
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedPodTemplate(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): PodTemplate {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapicorev1PodTemplateLens = Body.auto<PodTemplate>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/podtemplates/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodTemplateLens(response)
    }

    /**
     * read the specified PodTemplate
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedPodTemplate(
        name: String,
        namespace: String,
        pretty: String? = null
    ): PodTemplate {
        val iok8sapicorev1PodTemplateLens = Body.auto<PodTemplate>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/podtemplates/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodTemplateLens(response)
    }

    /**
     * partially update the specified PodTemplate
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedPodTemplate(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PodTemplate {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1PodTemplateLens = Body.auto<PodTemplate>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/podtemplates/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodTemplateLens(response)
    }

    /**
     * replace the specified PodTemplate
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedPodTemplate(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1PodTemplate: PodTemplate
    ): PodTemplate {
        val iok8sapicorev1PodTemplateLens = Body.auto<PodTemplate>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/podtemplates/{name}")
            .with(iok8sapicorev1PodTemplateLens of iok8sapicorev1PodTemplate)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodTemplateLens(response)
    }

    /**
     * delete collection of ReplicationController
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedReplicationController(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/replicationcontrollers")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ReplicationController
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedReplicationController(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ReplicationControllerList {
        val iok8sapicorev1ReplicationControllerListLens = Body.auto<ReplicationControllerList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/replicationcontrollers")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ReplicationControllerListLens(response)
    }

    /**
     * create a ReplicationController
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedReplicationController(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ReplicationController: ReplicationController
    ): ReplicationController {
        val iok8sapicorev1ReplicationControllerLens = Body.auto<ReplicationController>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/replicationcontrollers")
            .with(iok8sapicorev1ReplicationControllerLens of iok8sapicorev1ReplicationController)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ReplicationControllerLens(response)
    }

    /**
     * delete a ReplicationController
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedReplicationController(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ReplicationController
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedReplicationController(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ReplicationController {
        val iok8sapicorev1ReplicationControllerLens = Body.auto<ReplicationController>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ReplicationControllerLens(response)
    }

    /**
     * partially update the specified ReplicationController
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedReplicationController(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ReplicationController {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1ReplicationControllerLens = Body.auto<ReplicationController>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ReplicationControllerLens(response)
    }

    /**
     * replace the specified ReplicationController
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedReplicationController(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ReplicationController: ReplicationController
    ): ReplicationController {
        val iok8sapicorev1ReplicationControllerLens = Body.auto<ReplicationController>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}")
            .with(iok8sapicorev1ReplicationControllerLens of iok8sapicorev1ReplicationController)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ReplicationControllerLens(response)
    }

    /**
     * read scale of the specified ReplicationController
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedReplicationControllerScale(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Scale {
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * partially update scale of the specified ReplicationController
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedReplicationControllerScale(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Scale {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * replace scale of the specified ReplicationController
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedReplicationControllerScale(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv1Scale: Scale
    ): Scale {
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale")
            .with(iok8sapiautoscalingv1ScaleLens of iok8sapiautoscalingv1Scale)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * read status of the specified ReplicationController
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedReplicationControllerStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ReplicationController {
        val iok8sapicorev1ReplicationControllerLens = Body.auto<ReplicationController>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ReplicationControllerLens(response)
    }

    /**
     * partially update status of the specified ReplicationController
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedReplicationControllerStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ReplicationController {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1ReplicationControllerLens = Body.auto<ReplicationController>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ReplicationControllerLens(response)
    }

    /**
     * replace status of the specified ReplicationController
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedReplicationControllerStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ReplicationController: ReplicationController
    ): ReplicationController {
        val iok8sapicorev1ReplicationControllerLens = Body.auto<ReplicationController>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status")
            .with(iok8sapicorev1ReplicationControllerLens of iok8sapicorev1ReplicationController)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ReplicationControllerLens(response)
    }

    /**
     * delete collection of ResourceQuota
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedResourceQuota(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/resourcequotas")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ResourceQuota
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedResourceQuota(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ResourceQuotaList {
        val iok8sapicorev1ResourceQuotaListLens = Body.auto<ResourceQuotaList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/resourcequotas")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaListLens(response)
    }

    /**
     * create a ResourceQuota
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedResourceQuota(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ResourceQuota: ResourceQuota
    ): ResourceQuota {
        val iok8sapicorev1ResourceQuotaLens = Body.auto<ResourceQuota>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/resourcequotas")
            .with(iok8sapicorev1ResourceQuotaLens of iok8sapicorev1ResourceQuota)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaLens(response)
    }

    /**
     * delete a ResourceQuota
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedResourceQuota(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): ResourceQuota {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapicorev1ResourceQuotaLens = Body.auto<ResourceQuota>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/resourcequotas/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaLens(response)
    }

    /**
     * read the specified ResourceQuota
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedResourceQuota(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ResourceQuota {
        val iok8sapicorev1ResourceQuotaLens = Body.auto<ResourceQuota>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/resourcequotas/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaLens(response)
    }

    /**
     * partially update the specified ResourceQuota
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedResourceQuota(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ResourceQuota {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1ResourceQuotaLens = Body.auto<ResourceQuota>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/resourcequotas/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaLens(response)
    }

    /**
     * replace the specified ResourceQuota
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedResourceQuota(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ResourceQuota: ResourceQuota
    ): ResourceQuota {
        val iok8sapicorev1ResourceQuotaLens = Body.auto<ResourceQuota>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/resourcequotas/{name}")
            .with(iok8sapicorev1ResourceQuotaLens of iok8sapicorev1ResourceQuota)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaLens(response)
    }

    /**
     * read status of the specified ResourceQuota
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedResourceQuotaStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ResourceQuota {
        val iok8sapicorev1ResourceQuotaLens = Body.auto<ResourceQuota>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaLens(response)
    }

    /**
     * partially update status of the specified ResourceQuota
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedResourceQuotaStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ResourceQuota {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1ResourceQuotaLens = Body.auto<ResourceQuota>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaLens(response)
    }

    /**
     * replace status of the specified ResourceQuota
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedResourceQuotaStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ResourceQuota: ResourceQuota
    ): ResourceQuota {
        val iok8sapicorev1ResourceQuotaLens = Body.auto<ResourceQuota>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status")
            .with(iok8sapicorev1ResourceQuotaLens of iok8sapicorev1ResourceQuota)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaLens(response)
    }

    /**
     * delete collection of Secret
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedSecret(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/secrets")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Secret
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedSecret(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): SecretList {
        val iok8sapicorev1SecretListLens = Body.auto<SecretList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/secrets")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1SecretListLens(response)
    }

    /**
     * create a Secret
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedSecret(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Secret: Secret
    ): Secret {
        val iok8sapicorev1SecretLens = Body.auto<Secret>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/secrets")
            .with(iok8sapicorev1SecretLens of iok8sapicorev1Secret)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1SecretLens(response)
    }

    /**
     * delete a Secret
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedSecret(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/secrets/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Secret
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedSecret(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Secret {
        val iok8sapicorev1SecretLens = Body.auto<Secret>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/secrets/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1SecretLens(response)
    }

    /**
     * partially update the specified Secret
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedSecret(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Secret {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1SecretLens = Body.auto<Secret>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/secrets/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1SecretLens(response)
    }

    /**
     * replace the specified Secret
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedSecret(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Secret: Secret
    ): Secret {
        val iok8sapicorev1SecretLens = Body.auto<Secret>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/secrets/{name}")
            .with(iok8sapicorev1SecretLens of iok8sapicorev1Secret)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1SecretLens(response)
    }

    /**
     * delete collection of ServiceAccount
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedServiceAccount(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/serviceaccounts")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ServiceAccount
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedServiceAccount(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ServiceAccountList {
        val iok8sapicorev1ServiceAccountListLens = Body.auto<ServiceAccountList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/serviceaccounts")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceAccountListLens(response)
    }

    /**
     * create a ServiceAccount
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedServiceAccount(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ServiceAccount: ServiceAccount
    ): ServiceAccount {
        val iok8sapicorev1ServiceAccountLens = Body.auto<ServiceAccount>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/serviceaccounts")
            .with(iok8sapicorev1ServiceAccountLens of iok8sapicorev1ServiceAccount)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceAccountLens(response)
    }

    /**
     * delete a ServiceAccount
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedServiceAccount(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): ServiceAccount {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapicorev1ServiceAccountLens = Body.auto<ServiceAccount>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceAccountLens(response)
    }

    /**
     * read the specified ServiceAccount
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedServiceAccount(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ServiceAccount {
        val iok8sapicorev1ServiceAccountLens = Body.auto<ServiceAccount>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceAccountLens(response)
    }

    /**
     * partially update the specified ServiceAccount
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedServiceAccount(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ServiceAccount {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1ServiceAccountLens = Body.auto<ServiceAccount>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceAccountLens(response)
    }

    /**
     * replace the specified ServiceAccount
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedServiceAccount(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1ServiceAccount: ServiceAccount
    ): ServiceAccount {
        val iok8sapicorev1ServiceAccountLens = Body.auto<ServiceAccount>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}")
            .with(iok8sapicorev1ServiceAccountLens of iok8sapicorev1ServiceAccount)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceAccountLens(response)
    }

    /**
     * create token of a ServiceAccount
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedServiceAccountToken(
        name: String,
        namespace: String,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapiauthenticationv1TokenRequest: TokenRequest
    ): TokenRequest {
        val iok8sapiauthenticationv1TokenRequestLens = Body.auto<TokenRequest>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}/token")
            .with(iok8sapiauthenticationv1TokenRequestLens of iok8sapiauthenticationv1TokenRequest)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiauthenticationv1TokenRequestLens(response)
    }

    /**
     * delete collection of Service
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNamespacedService(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/services")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Service
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1NamespacedService(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ServiceList {
        val iok8sapicorev1ServiceListLens = Body.auto<ServiceList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/services")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceListLens(response)
    }

    /**
     * create a Service
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1NamespacedService(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Service: Service
    ): Service {
        val iok8sapicorev1ServiceLens = Body.auto<Service>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/services")
            .with(iok8sapicorev1ServiceLens of iok8sapicorev1Service)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceLens(response)
    }

    /**
     * delete a Service
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1NamespacedService(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Service {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapicorev1ServiceLens = Body.auto<Service>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/services/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceLens(response)
    }

    /**
     * read the specified Service
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedService(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Service {
        val iok8sapicorev1ServiceLens = Body.auto<Service>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/services/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceLens(response)
    }

    /**
     * partially update the specified Service
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedService(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Service {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1ServiceLens = Body.auto<Service>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/services/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceLens(response)
    }

    /**
     * replace the specified Service
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedService(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Service: Service
    ): Service {
        val iok8sapicorev1ServiceLens = Body.auto<Service>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/services/{name}")
            .with(iok8sapicorev1ServiceLens of iok8sapicorev1Service)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceLens(response)
    }

    /**
     * connect DELETE requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1DeleteNamespacedServiceProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1DeleteNamespacedServiceProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/services/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1DeleteNamespacedServiceProxyResponse200Lens(response)
    }

    /**
     * connect GET requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1GetNamespacedServiceProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1GetNamespacedServiceProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/services/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1GetNamespacedServiceProxyResponse200Lens(response)
    }

    /**
     * connect HEAD requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1HeadNamespacedServiceProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1HeadNamespacedServiceProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.HEAD, "/api/v1/namespaces/{namespace}/services/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1HeadNamespacedServiceProxyResponse200Lens(response)
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1OptionsNamespacedServiceProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1OptionsNamespacedServiceProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.OPTIONS, "/api/v1/namespaces/{namespace}/services/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1OptionsNamespacedServiceProxyResponse200Lens(response)
    }

    /**
     * connect PATCH requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PatchNamespacedServiceProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1PatchNamespacedServiceProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/services/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PatchNamespacedServiceProxyResponse200Lens(response)
    }

    /**
     * connect POST requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PostNamespacedServiceProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1PostNamespacedServiceProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/services/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PostNamespacedServiceProxyResponse200Lens(response)
    }

    /**
     * connect PUT requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PutNamespacedServiceProxy(
        name: String,
        namespace: String,
        path: String? = null
    ): String {
        val connectCoreV1PutNamespacedServiceProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/services/{name}/proxy")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PutNamespacedServiceProxyResponse200Lens(response)
    }

    /**
     * connect DELETE requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1DeleteNamespacedServiceProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1DeleteNamespacedServiceProxyWithPathResponse200Lens =
            Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1DeleteNamespacedServiceProxyWithPathResponse200Lens(response)
    }

    /**
     * connect GET requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1GetNamespacedServiceProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1GetNamespacedServiceProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1GetNamespacedServiceProxyWithPathResponse200Lens(response)
    }

    /**
     * connect HEAD requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1HeadNamespacedServiceProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1HeadNamespacedServiceProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.HEAD, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1HeadNamespacedServiceProxyWithPathResponse200Lens(response)
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1OptionsNamespacedServiceProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1OptionsNamespacedServiceProxyWithPathResponse200Lens =
            Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.OPTIONS, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1OptionsNamespacedServiceProxyWithPathResponse200Lens(response)
    }

    /**
     * connect PATCH requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PatchNamespacedServiceProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1PatchNamespacedServiceProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PatchNamespacedServiceProxyWithPathResponse200Lens(response)
    }

    /**
     * connect POST requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PostNamespacedServiceProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1PostNamespacedServiceProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.POST, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PostNamespacedServiceProxyWithPathResponse200Lens(response)
    }

    /**
     * connect PUT requests to proxy of Service
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PutNamespacedServiceProxyWithPath(
        name: String,
        namespace: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1PutNamespacedServiceProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PutNamespacedServiceProxyWithPathResponse200Lens(response)
    }

    /**
     * read status of the specified Service
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespacedServiceStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Service {
        val iok8sapicorev1ServiceLens = Body.auto<Service>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{namespace}/services/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceLens(response)
    }

    /**
     * partially update status of the specified Service
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespacedServiceStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Service {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1ServiceLens = Body.auto<Service>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{namespace}/services/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceLens(response)
    }

    /**
     * replace status of the specified Service
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespacedServiceStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Service: Service
    ): Service {
        val iok8sapicorev1ServiceLens = Body.auto<Service>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{namespace}/services/{name}/status")
            .with(iok8sapicorev1ServiceLens of iok8sapicorev1Service)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceLens(response)
    }

    /**
     * delete a Namespace
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1Namespace(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/namespaces/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Namespace
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1Namespace(name: String, pretty: String? = null): Namespace {
        val iok8sapicorev1NamespaceLens = Body.auto<Namespace>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NamespaceLens(response)
    }

    /**
     * partially update the specified Namespace
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1Namespace(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Namespace {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1NamespaceLens = Body.auto<Namespace>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NamespaceLens(response)
    }

    /**
     * replace the specified Namespace
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1Namespace(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Namespace: Namespace
    ): Namespace {
        val iok8sapicorev1NamespaceLens = Body.auto<Namespace>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{name}")
            .with(iok8sapicorev1NamespaceLens of iok8sapicorev1Namespace)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NamespaceLens(response)
    }

    /**
     * replace finalize of the specified Namespace
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespaceFinalize(
        name: String,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapicorev1Namespace: Namespace
    ): Namespace {
        val iok8sapicorev1NamespaceLens = Body.auto<Namespace>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{name}/finalize")
            .with(iok8sapicorev1NamespaceLens of iok8sapicorev1Namespace)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NamespaceLens(response)
    }

    /**
     * read status of the specified Namespace
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NamespaceStatus(name: String, pretty: String? = null): Namespace {
        val iok8sapicorev1NamespaceLens = Body.auto<Namespace>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/namespaces/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NamespaceLens(response)
    }

    /**
     * partially update status of the specified Namespace
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NamespaceStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Namespace {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1NamespaceLens = Body.auto<Namespace>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/namespaces/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NamespaceLens(response)
    }

    /**
     * replace status of the specified Namespace
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NamespaceStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Namespace: Namespace
    ): Namespace {
        val iok8sapicorev1NamespaceLens = Body.auto<Namespace>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/namespaces/{name}/status")
            .with(iok8sapicorev1NamespaceLens of iok8sapicorev1Namespace)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NamespaceLens(response)
    }

    /**
     * delete collection of Node
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionNode(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/nodes")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Node
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1Node(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): NodeList {
        val iok8sapicorev1NodeListLens = Body.auto<NodeList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/nodes")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NodeListLens(response)
    }

    /**
     * create a Node
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1Node(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Node: Node
    ): Node {
        val iok8sapicorev1NodeLens = Body.auto<Node>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/nodes")
            .with(iok8sapicorev1NodeLens of iok8sapicorev1Node)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NodeLens(response)
    }

    /**
     * delete a Node
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1Node(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/nodes/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Node
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1Node(name: String, pretty: String? = null): Node {
        val iok8sapicorev1NodeLens = Body.auto<Node>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/nodes/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NodeLens(response)
    }

    /**
     * partially update the specified Node
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1Node(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Node {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1NodeLens = Body.auto<Node>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/nodes/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NodeLens(response)
    }

    /**
     * replace the specified Node
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1Node(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Node: Node
    ): Node {
        val iok8sapicorev1NodeLens = Body.auto<Node>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/nodes/{name}")
            .with(iok8sapicorev1NodeLens of iok8sapicorev1Node)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NodeLens(response)
    }

    /**
     * connect DELETE requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1DeleteNodeProxy(name: String, path: String? = null): String {
        val connectCoreV1DeleteNodeProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.DELETE, "/api/v1/nodes/{name}/proxy")
            .with(nameLens of name)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1DeleteNodeProxyResponse200Lens(response)
    }

    /**
     * connect GET requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1GetNodeProxy(name: String, path: String? = null): String {
        val connectCoreV1GetNodeProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.GET, "/api/v1/nodes/{name}/proxy")
            .with(nameLens of name)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1GetNodeProxyResponse200Lens(response)
    }

    /**
     * connect HEAD requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1HeadNodeProxy(name: String, path: String? = null): String {
        val connectCoreV1HeadNodeProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.HEAD, "/api/v1/nodes/{name}/proxy")
            .with(nameLens of name)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1HeadNodeProxyResponse200Lens(response)
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1OptionsNodeProxy(name: String, path: String? = null): String {
        val connectCoreV1OptionsNodeProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.OPTIONS, "/api/v1/nodes/{name}/proxy")
            .with(nameLens of name)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1OptionsNodeProxyResponse200Lens(response)
    }

    /**
     * connect PATCH requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PatchNodeProxy(name: String, path: String? = null): String {
        val connectCoreV1PatchNodeProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.PATCH, "/api/v1/nodes/{name}/proxy")
            .with(nameLens of name)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PatchNodeProxyResponse200Lens(response)
    }

    /**
     * connect POST requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PostNodeProxy(name: String, path: String? = null): String {
        val connectCoreV1PostNodeProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.POST, "/api/v1/nodes/{name}/proxy")
            .with(nameLens of name)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PostNodeProxyResponse200Lens(response)
    }

    /**
     * connect PUT requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PutNodeProxy(name: String, path: String? = null): String {
        val connectCoreV1PutNodeProxyResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Query.string().optional("path")
        val httpReq = Request(Method.PUT, "/api/v1/nodes/{name}/proxy")
            .with(nameLens of name)
            .with(pathLens of path)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PutNodeProxyResponse200Lens(response)
    }

    /**
     * connect DELETE requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1DeleteNodeProxyWithPath(
        name: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1DeleteNodeProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.DELETE, "/api/v1/nodes/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1DeleteNodeProxyWithPathResponse200Lens(response)
    }

    /**
     * connect GET requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1GetNodeProxyWithPath(
        name: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1GetNodeProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.GET, "/api/v1/nodes/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1GetNodeProxyWithPathResponse200Lens(response)
    }

    /**
     * connect HEAD requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1HeadNodeProxyWithPath(
        name: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1HeadNodeProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.HEAD, "/api/v1/nodes/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1HeadNodeProxyWithPathResponse200Lens(response)
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1OptionsNodeProxyWithPath(
        name: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1OptionsNodeProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.OPTIONS, "/api/v1/nodes/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1OptionsNodeProxyWithPathResponse200Lens(response)
    }

    /**
     * connect PATCH requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PatchNodeProxyWithPath(
        name: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1PatchNodeProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.PATCH, "/api/v1/nodes/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PatchNodeProxyWithPathResponse200Lens(response)
    }

    /**
     * connect POST requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PostNodeProxyWithPath(
        name: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1PostNodeProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.POST, "/api/v1/nodes/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PostNodeProxyWithPathResponse200Lens(response)
    }

    /**
     * connect PUT requests to proxy of Node
     * Response:
     * 	* / *
     * 		200 OK
     * 		401 Unauthorized
     */
    fun connectCoreV1PutNodeProxyWithPath(
        name: String,
        path: String,
        pathQuery: String? = null
    ): String {
        val connectCoreV1PutNodeProxyWithPathResponse200Lens = Body.auto<String>().toLens()
        val nameLens = Path.string().of("name")
        val pathLens = Path.string().of("path")
        val pathQueryLens = Query.string().optional("path")
        val httpReq = Request(Method.PUT, "/api/v1/nodes/{name}/proxy/{path}")
            .with(nameLens of name)
            .with(pathLens of path)
            .with(pathQueryLens of pathQuery)
        val response = bearerToken.then(httpHandler)(httpReq)
        return connectCoreV1PutNodeProxyWithPathResponse200Lens(response)
    }

    /**
     * read status of the specified Node
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1NodeStatus(name: String, pretty: String? = null): Node {
        val iok8sapicorev1NodeLens = Body.auto<Node>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/nodes/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NodeLens(response)
    }

    /**
     * partially update status of the specified Node
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1NodeStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Node {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1NodeLens = Body.auto<Node>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/nodes/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NodeLens(response)
    }

    /**
     * replace status of the specified Node
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1NodeStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1Node: Node
    ): Node {
        val iok8sapicorev1NodeLens = Body.auto<Node>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/nodes/{name}/status")
            .with(iok8sapicorev1NodeLens of iok8sapicorev1Node)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1NodeLens(response)
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1PersistentVolumeClaimForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PersistentVolumeClaimList {
        val iok8sapicorev1PersistentVolumeClaimListLens = Body.auto<PersistentVolumeClaimList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/persistentvolumeclaims")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeClaimListLens(response)
    }

    /**
     * delete collection of PersistentVolume
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoreV1CollectionPersistentVolume(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/api/v1/persistentvolumes")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind PersistentVolume
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1PersistentVolume(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PersistentVolumeList {
        val iok8sapicorev1PersistentVolumeListLens = Body.auto<PersistentVolumeList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/persistentvolumes")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeListLens(response)
    }

    /**
     * create a PersistentVolume
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoreV1PersistentVolume(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1PersistentVolume: PersistentVolume
    ): PersistentVolume {
        val iok8sapicorev1PersistentVolumeLens = Body.auto<PersistentVolume>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/api/v1/persistentvolumes")
            .with(iok8sapicorev1PersistentVolumeLens of iok8sapicorev1PersistentVolume)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeLens(response)
    }

    /**
     * delete a PersistentVolume
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoreV1PersistentVolume(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): PersistentVolume {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapicorev1PersistentVolumeLens = Body.auto<PersistentVolume>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/api/v1/persistentvolumes/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeLens(response)
    }

    /**
     * read the specified PersistentVolume
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1PersistentVolume(name: String, pretty: String? = null): PersistentVolume {
        val iok8sapicorev1PersistentVolumeLens = Body.auto<PersistentVolume>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/persistentvolumes/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeLens(response)
    }

    /**
     * partially update the specified PersistentVolume
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1PersistentVolume(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PersistentVolume {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1PersistentVolumeLens = Body.auto<PersistentVolume>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/persistentvolumes/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeLens(response)
    }

    /**
     * replace the specified PersistentVolume
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1PersistentVolume(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1PersistentVolume: PersistentVolume
    ): PersistentVolume {
        val iok8sapicorev1PersistentVolumeLens = Body.auto<PersistentVolume>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/persistentvolumes/{name}")
            .with(iok8sapicorev1PersistentVolumeLens of iok8sapicorev1PersistentVolume)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeLens(response)
    }

    /**
     * read status of the specified PersistentVolume
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoreV1PersistentVolumeStatus(name: String, pretty: String? = null):
        PersistentVolume {
        val iok8sapicorev1PersistentVolumeLens = Body.auto<PersistentVolume>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/api/v1/persistentvolumes/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeLens(response)
    }

    /**
     * partially update status of the specified PersistentVolume
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoreV1PersistentVolumeStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PersistentVolume {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicorev1PersistentVolumeLens = Body.auto<PersistentVolume>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/api/v1/persistentvolumes/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeLens(response)
    }

    /**
     * replace status of the specified PersistentVolume
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoreV1PersistentVolumeStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicorev1PersistentVolume: PersistentVolume
    ): PersistentVolume {
        val iok8sapicorev1PersistentVolumeLens = Body.auto<PersistentVolume>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/api/v1/persistentvolumes/{name}/status")
            .with(iok8sapicorev1PersistentVolumeLens of iok8sapicorev1PersistentVolume)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PersistentVolumeLens(response)
    }

    /**
     * list or watch objects of kind Pod
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1PodForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PodList {
        val iok8sapicorev1PodListLens = Body.auto<PodList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/pods")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodListLens(response)
    }

    /**
     * list or watch objects of kind PodTemplate
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1PodTemplateForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PodTemplateList {
        val iok8sapicorev1PodTemplateListLens = Body.auto<PodTemplateList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/podtemplates")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1PodTemplateListLens(response)
    }

    /**
     * list or watch objects of kind ReplicationController
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1ReplicationControllerForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ReplicationControllerList {
        val iok8sapicorev1ReplicationControllerListLens = Body.auto<ReplicationControllerList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/replicationcontrollers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ReplicationControllerListLens(response)
    }

    /**
     * list or watch objects of kind ResourceQuota
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1ResourceQuotaForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ResourceQuotaList {
        val iok8sapicorev1ResourceQuotaListLens = Body.auto<ResourceQuotaList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/resourcequotas")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ResourceQuotaListLens(response)
    }

    /**
     * list or watch objects of kind Secret
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1SecretForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): SecretList {
        val iok8sapicorev1SecretListLens = Body.auto<SecretList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/secrets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1SecretListLens(response)
    }

    /**
     * list or watch objects of kind ServiceAccount
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1ServiceAccountForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ServiceAccountList {
        val iok8sapicorev1ServiceAccountListLens = Body.auto<ServiceAccountList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/serviceaccounts")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceAccountListLens(response)
    }

    /**
     * list or watch objects of kind Service
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoreV1ServiceForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ServiceList {
        val iok8sapicorev1ServiceListLens = Body.auto<ServiceList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/services")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicorev1ServiceListLens(response)
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1ConfigMapListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/configmaps")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1EndpointsListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/endpoints")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1EventListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/events")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1LimitRangeListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/limitranges")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Namespace. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespaceList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedConfigMapList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/configmaps")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ConfigMap. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedConfigMap(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/configmaps/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedEndpointsList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/endpoints")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Endpoints. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedEndpoints(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/endpoints/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedEventList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/events")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedEvent(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/events/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedLimitRangeList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/limitranges")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind LimitRange. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedLimitRange(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/limitranges/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedPersistentVolumeClaimList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind PersistentVolumeClaim. deprecated: use the 'watch' parameter
     * with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedPersistentVolumeClaim(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedPodList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/pods")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Pod. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedPod(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/pods/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedPodTemplateList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/podtemplates")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind PodTemplate. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedPodTemplate(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/podtemplates/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedReplicationControllerList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/replicationcontrollers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ReplicationController. deprecated: use the 'watch' parameter
     * with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedReplicationController(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedResourceQuotaList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/resourcequotas")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ResourceQuota. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedResourceQuota(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedSecretList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/secrets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Secret. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedSecret(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/secrets/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedServiceAccountList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/serviceaccounts")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ServiceAccount. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedServiceAccount(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedServiceList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/services")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Service. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NamespacedService(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{namespace}/services/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Namespace. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1Namespace(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/namespaces/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Node. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1NodeList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/nodes")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Node. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1Node(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/nodes/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1PersistentVolumeClaimListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/persistentvolumeclaims")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of PersistentVolume. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1PersistentVolumeList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/persistentvolumes")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind PersistentVolume. deprecated: use the 'watch' parameter with
     * a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1PersistentVolume(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/persistentvolumes/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1PodListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/pods")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1PodTemplateListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/podtemplates")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1ReplicationControllerListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/replicationcontrollers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1ResourceQuotaListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/resourcequotas")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1SecretListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/secrets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1ServiceAccountListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/serviceaccounts")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoreV1ServiceListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/api/v1/watch/services")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get available API versions
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAPIVersions(): APIGroupList {
        val iok8sapimachinerypkgapismetav1APIGroupListLens = Body.auto<APIGroupList>().toLens()
        val httpReq = Request(Method.GET, "/apis/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupListLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAdmissionregistrationAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/admissionregistration.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAdmissionregistrationV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/admissionregistration.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of MutatingWebhookConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind MutatingWebhookConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAdmissionregistrationV1MutatingWebhookConfiguration(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): MutatingWebhookConfigurationList {
        val iok8sapiadmissionregistrationv1MutatingWebhookConfigurationListLens =
            Body.auto<MutatingWebhookConfigurationList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1MutatingWebhookConfigurationListLens(response)
    }

    /**
     * create a MutatingWebhookConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAdmissionregistrationV1MutatingWebhookConfiguration(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiadmissionregistrationv1MutatingWebhookConfiguration: MutatingWebhookConfiguration
    ): MutatingWebhookConfiguration {
        val iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens =
            Body.auto<MutatingWebhookConfiguration>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations")
            .with(iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens of iok8sapiadmissionregistrationv1MutatingWebhookConfiguration)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens(response)
    }

    /**
     * delete a MutatingWebhookConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAdmissionregistrationV1MutatingWebhookConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified MutatingWebhookConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAdmissionregistrationV1MutatingWebhookConfiguration(
        name: String, pretty: String? =
            null
    ): MutatingWebhookConfiguration {
        val iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens =
            Body.auto<MutatingWebhookConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens(response)
    }

    /**
     * partially update the specified MutatingWebhookConfiguration
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAdmissionregistrationV1MutatingWebhookConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): MutatingWebhookConfiguration {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens =
            Body.auto<MutatingWebhookConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens(response)
    }

    /**
     * replace the specified MutatingWebhookConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAdmissionregistrationV1MutatingWebhookConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiadmissionregistrationv1MutatingWebhookConfiguration: MutatingWebhookConfiguration
    ): MutatingWebhookConfiguration {
        val iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens =
            Body.auto<MutatingWebhookConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}")
            .with(iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens of iok8sapiadmissionregistrationv1MutatingWebhookConfiguration)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1MutatingWebhookConfigurationLens(response)
    }

    /**
     * delete collection of ValidatingWebhookConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ValidatingWebhookConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAdmissionregistrationV1ValidatingWebhookConfiguration(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ValidatingWebhookConfigurationList {
        val iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationListLens =
            Body.auto<ValidatingWebhookConfigurationList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationListLens(response)
    }

    /**
     * create a ValidatingWebhookConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAdmissionregistrationV1ValidatingWebhookConfiguration(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiadmissionregistrationv1ValidatingWebhookConfiguration: ValidatingWebhookConfiguration
    ): ValidatingWebhookConfiguration {
        val iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens =
            Body.auto<ValidatingWebhookConfiguration>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations")
            .with(iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens of iok8sapiadmissionregistrationv1ValidatingWebhookConfiguration)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens(response)
    }

    /**
     * delete a ValidatingWebhookConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAdmissionregistrationV1ValidatingWebhookConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ValidatingWebhookConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAdmissionregistrationV1ValidatingWebhookConfiguration(
        name: String, pretty: String?
        = null
    ): ValidatingWebhookConfiguration {
        val iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens =
            Body.auto<ValidatingWebhookConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}")
                .with(nameLens of name)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens(response)
    }

    /**
     * partially update the specified ValidatingWebhookConfiguration
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAdmissionregistrationV1ValidatingWebhookConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ValidatingWebhookConfiguration {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens =
            Body.auto<ValidatingWebhookConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens(response)
    }

    /**
     * replace the specified ValidatingWebhookConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAdmissionregistrationV1ValidatingWebhookConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiadmissionregistrationv1ValidatingWebhookConfiguration: ValidatingWebhookConfiguration
    ): ValidatingWebhookConfiguration {
        val iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens =
            Body.auto<ValidatingWebhookConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}")
                .with(iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens of iok8sapiadmissionregistrationv1ValidatingWebhookConfiguration)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1ValidatingWebhookConfigurationLens(response)
    }

    /**
     * watch individual changes to a list of MutatingWebhookConfiguration. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAdmissionregistrationV1MutatingWebhookConfigurationList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind MutatingWebhookConfiguration. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAdmissionregistrationV1MutatingWebhookConfiguration(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ValidatingWebhookConfiguration. deprecated: use the
     * 'watch' parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAdmissionregistrationV1ValidatingWebhookConfigurationList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ValidatingWebhookConfiguration. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAdmissionregistrationV1ValidatingWebhookConfiguration(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAdmissionregistrationV1alpha1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/admissionregistration.k8s.io/v1alpha1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of ValidatingAdmissionPolicy
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAdmissionregistrationV1alpha1CollectionValidatingAdmissionPolicy(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicy
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAdmissionregistrationV1alpha1ValidatingAdmissionPolicy(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ValidatingAdmissionPolicyList {
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyListLens =
            Body.auto<ValidatingAdmissionPolicyList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyListLens(response)
    }

    /**
     * create a ValidatingAdmissionPolicy
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAdmissionregistrationV1alpha1ValidatingAdmissionPolicy(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicy: ValidatingAdmissionPolicy
    ): ValidatingAdmissionPolicy {
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens =
            Body.auto<ValidatingAdmissionPolicy>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies")
            .with(iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens of iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicy)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens(response)
    }

    /**
     * delete a ValidatingAdmissionPolicy
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAdmissionregistrationV1alpha1ValidatingAdmissionPolicy(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ValidatingAdmissionPolicy
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAdmissionregistrationV1alpha1ValidatingAdmissionPolicy(
        name: String, pretty: String?
        = null
    ): ValidatingAdmissionPolicy {
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens =
            Body.auto<ValidatingAdmissionPolicy>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}")
                .with(nameLens of name)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens(response)
    }

    /**
     * partially update the specified ValidatingAdmissionPolicy
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAdmissionregistrationV1alpha1ValidatingAdmissionPolicy(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ValidatingAdmissionPolicy {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens =
            Body.auto<ValidatingAdmissionPolicy>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens(response)
    }

    /**
     * replace the specified ValidatingAdmissionPolicy
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAdmissionregistrationV1alpha1ValidatingAdmissionPolicy(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicy: ValidatingAdmissionPolicy
    ): ValidatingAdmissionPolicy {
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens =
            Body.auto<ValidatingAdmissionPolicy>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}")
                .with(iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens of iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicy)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyLens(response)
    }

    /**
     * delete collection of ValidatingAdmissionPolicyBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAdmissionregistrationV1alpha1CollectionValidatingAdmissionPolicyBinding(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq =
            Request(Method.DELETE, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(prettyLens of pretty)
                .with(continueLens of `continue`)
                .with(dryRunLens of dryRun)
                .with(fieldSelectorLens of fieldSelector)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicyBinding
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAdmissionregistrationV1alpha1ValidatingAdmissionPolicyBinding(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ValidatingAdmissionPolicyBindingList {
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingListLens =
            Body.auto<ValidatingAdmissionPolicyBindingList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings")
                .with(prettyLens of pretty)
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingListLens(response)
    }

    /**
     * create a ValidatingAdmissionPolicyBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAdmissionregistrationV1alpha1ValidatingAdmissionPolicyBinding(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBinding: ValidatingAdmissionPolicyBinding
    ): ValidatingAdmissionPolicyBinding {
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens =
            Body.auto<ValidatingAdmissionPolicyBinding>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.POST, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings")
                .with(iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens of iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBinding)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens(response)
    }

    /**
     * delete a ValidatingAdmissionPolicyBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAdmissionregistrationV1alpha1ValidatingAdmissionPolicyBinding(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(
            Method.DELETE,
            "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings/{name}"
        )
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ValidatingAdmissionPolicyBinding
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAdmissionregistrationV1alpha1ValidatingAdmissionPolicyBinding(
        name: String,
        pretty: String? = null
    ): ValidatingAdmissionPolicyBinding {
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens =
            Body.auto<ValidatingAdmissionPolicyBinding>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings/{name}")
                .with(nameLens of name)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens(response)
    }

    /**
     * partially update the specified ValidatingAdmissionPolicyBinding
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAdmissionregistrationV1alpha1ValidatingAdmissionPolicyBinding(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ValidatingAdmissionPolicyBinding {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens =
            Body.auto<ValidatingAdmissionPolicyBinding>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(
            Method.PATCH,
            "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings/{name}"
        )
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens(response)
    }

    /**
     * replace the specified ValidatingAdmissionPolicyBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAdmissionregistrationV1alpha1ValidatingAdmissionPolicyBinding(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBinding: ValidatingAdmissionPolicyBinding
    ): ValidatingAdmissionPolicyBinding {
        val iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens =
            Body.auto<ValidatingAdmissionPolicyBinding>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings/{name}")
                .with(iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens of iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBinding)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiadmissionregistrationv1alpha1ValidatingAdmissionPolicyBindingLens(response)
    }

    /**
     * watch individual changes to a list of ValidatingAdmissionPolicy. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAdmissionregistrationV1alpha1ValidatingAdmissionPolicyList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/admissionregistration.k8s.io/v1alpha1/watch/validatingadmissionpolicies")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ValidatingAdmissionPolicy. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAdmissionregistrationV1alpha1ValidatingAdmissionPolicy(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/admissionregistration.k8s.io/v1alpha1/watch/validatingadmissionpolicies/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ValidatingAdmissionPolicyBinding. deprecated: use the
     * 'watch' parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAdmissionregistrationV1alpha1ValidatingAdmissionPolicyBindingList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/admissionregistration.k8s.io/v1alpha1/watch/validatingadmissionpolicybindings")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ValidatingAdmissionPolicyBinding. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAdmissionregistrationV1alpha1ValidatingAdmissionPolicyBinding(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(
            Method.GET,
            "/apis/admissionregistration.k8s.io/v1alpha1/watch/validatingadmissionpolicybindings/{name}"
        )
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getApiextensionsAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/apiextensions.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getApiextensionsV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/apiextensions.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of CustomResourceDefinition
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteApiextensionsV1CollectionCustomResourceDefinition(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind CustomResourceDefinition
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listApiextensionsV1CustomResourceDefinition(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): CustomResourceDefinitionList {
        val iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionListLens =
            Body.auto<CustomResourceDefinitionList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionListLens(response)
    }

    /**
     * create a CustomResourceDefinition
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createApiextensionsV1CustomResourceDefinition(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinition: CustomResourceDefinition
    ): CustomResourceDefinition {
        val iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens =
            Body.auto<CustomResourceDefinition>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions")
            .with(iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens of iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinition)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens(response)
    }

    /**
     * delete a CustomResourceDefinition
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteApiextensionsV1CustomResourceDefinition(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified CustomResourceDefinition
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readApiextensionsV1CustomResourceDefinition(name: String, pretty: String? = null):
        CustomResourceDefinition {
        val iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens =
            Body.auto<CustomResourceDefinition>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens(response)
    }

    /**
     * partially update the specified CustomResourceDefinition
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchApiextensionsV1CustomResourceDefinition(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CustomResourceDefinition {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens =
            Body.auto<CustomResourceDefinition>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens(response)
    }

    /**
     * replace the specified CustomResourceDefinition
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceApiextensionsV1CustomResourceDefinition(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinition: CustomResourceDefinition
    ): CustomResourceDefinition {
        val iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens =
            Body.auto<CustomResourceDefinition>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}")
            .with(iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens of iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinition)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens(response)
    }

    /**
     * read status of the specified CustomResourceDefinition
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readApiextensionsV1CustomResourceDefinitionStatus(name: String, pretty: String? = null):
        CustomResourceDefinition {
        val iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens =
            Body.auto<CustomResourceDefinition>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens(response)
    }

    /**
     * partially update status of the specified CustomResourceDefinition
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchApiextensionsV1CustomResourceDefinitionStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CustomResourceDefinition {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens =
            Body.auto<CustomResourceDefinition>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens(response)
    }

    /**
     * replace status of the specified CustomResourceDefinition
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceApiextensionsV1CustomResourceDefinitionStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinition: CustomResourceDefinition
    ): CustomResourceDefinition {
        val iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens =
            Body.auto<CustomResourceDefinition>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status")
            .with(iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens of iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinition)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiextensionsapiserverpkgapisapiextensionsv1CustomResourceDefinitionLens(response)
    }

    /**
     * watch individual changes to a list of CustomResourceDefinition. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchApiextensionsV1CustomResourceDefinitionList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind CustomResourceDefinition. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchApiextensionsV1CustomResourceDefinition(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getApiregistrationAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/apiregistration.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getApiregistrationV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/apiregistration.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of APIService
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteApiregistrationV1CollectionAPIService(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/apiregistration.k8s.io/v1/apiservices")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind APIService
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listApiregistrationV1APIService(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): APIServiceList {
        val iok8skubeaggregatorpkgapisapiregistrationv1APIServiceListLens =
            Body.auto<APIServiceList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apiregistration.k8s.io/v1/apiservices")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8skubeaggregatorpkgapisapiregistrationv1APIServiceListLens(response)
    }

    /**
     * create an APIService
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createApiregistrationV1APIService(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8skubeaggregatorpkgapisapiregistrationv1APIService: APIService
    ): APIService {
        val iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens = Body.auto<APIService>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/apiregistration.k8s.io/v1/apiservices")
            .with(iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens of iok8skubeaggregatorpkgapisapiregistrationv1APIService)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens(response)
    }

    /**
     * delete an APIService
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteApiregistrationV1APIService(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/apiregistration.k8s.io/v1/apiservices/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified APIService
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readApiregistrationV1APIService(name: String, pretty: String? = null): APIService {
        val iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens = Body.auto<APIService>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apiregistration.k8s.io/v1/apiservices/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens(response)
    }

    /**
     * partially update the specified APIService
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchApiregistrationV1APIService(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): APIService {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens = Body.auto<APIService>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apiregistration.k8s.io/v1/apiservices/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens(response)
    }

    /**
     * replace the specified APIService
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceApiregistrationV1APIService(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8skubeaggregatorpkgapisapiregistrationv1APIService: APIService
    ): APIService {
        val iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens = Body.auto<APIService>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apiregistration.k8s.io/v1/apiservices/{name}")
            .with(iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens of iok8skubeaggregatorpkgapisapiregistrationv1APIService)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens(response)
    }

    /**
     * read status of the specified APIService
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readApiregistrationV1APIServiceStatus(name: String, pretty: String? = null):
        APIService {
        val iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens = Body.auto<APIService>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apiregistration.k8s.io/v1/apiservices/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens(response)
    }

    /**
     * partially update status of the specified APIService
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchApiregistrationV1APIServiceStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): APIService {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens = Body.auto<APIService>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apiregistration.k8s.io/v1/apiservices/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens(response)
    }

    /**
     * replace status of the specified APIService
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceApiregistrationV1APIServiceStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8skubeaggregatorpkgapisapiregistrationv1APIService: APIService
    ): APIService {
        val iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens = Body.auto<APIService>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apiregistration.k8s.io/v1/apiservices/{name}/status")
            .with(iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens of iok8skubeaggregatorpkgapisapiregistrationv1APIService)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8skubeaggregatorpkgapisapiregistrationv1APIServiceLens(response)
    }

    /**
     * watch individual changes to a list of APIService. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchApiregistrationV1APIServiceList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apiregistration.k8s.io/v1/watch/apiservices")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind APIService. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchApiregistrationV1APIService(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apiregistration.k8s.io/v1/watch/apiservices/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAppsAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/apps/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAppsV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/apps/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * list or watch objects of kind ControllerRevision
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1ControllerRevisionForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ControllerRevisionList {
        val iok8sapiappsv1ControllerRevisionListLens = Body.auto<ControllerRevisionList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/controllerrevisions")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ControllerRevisionListLens(response)
    }

    /**
     * list or watch objects of kind DaemonSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1DaemonSetForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): DaemonSetList {
        val iok8sapiappsv1DaemonSetListLens = Body.auto<DaemonSetList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/daemonsets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DaemonSetListLens(response)
    }

    /**
     * list or watch objects of kind Deployment
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1DeploymentForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): DeploymentList {
        val iok8sapiappsv1DeploymentListLens = Body.auto<DeploymentList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/deployments")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DeploymentListLens(response)
    }

    /**
     * delete collection of ControllerRevision
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAppsV1CollectionNamespacedControllerRevision(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/controllerrevisions")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ControllerRevision
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1NamespacedControllerRevision(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ControllerRevisionList {
        val iok8sapiappsv1ControllerRevisionListLens = Body.auto<ControllerRevisionList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/controllerrevisions")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ControllerRevisionListLens(response)
    }

    /**
     * create a ControllerRevision
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAppsV1NamespacedControllerRevision(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1ControllerRevision: ControllerRevision
    ): ControllerRevision {
        val iok8sapiappsv1ControllerRevisionLens = Body.auto<ControllerRevision>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/apps/v1/namespaces/{namespace}/controllerrevisions")
            .with(iok8sapiappsv1ControllerRevisionLens of iok8sapiappsv1ControllerRevision)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ControllerRevisionLens(response)
    }

    /**
     * delete a ControllerRevision
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAppsV1NamespacedControllerRevision(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ControllerRevision
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedControllerRevision(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ControllerRevision {
        val iok8sapiappsv1ControllerRevisionLens = Body.auto<ControllerRevision>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ControllerRevisionLens(response)
    }

    /**
     * partially update the specified ControllerRevision
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedControllerRevision(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ControllerRevision {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiappsv1ControllerRevisionLens = Body.auto<ControllerRevision>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ControllerRevisionLens(response)
    }

    /**
     * replace the specified ControllerRevision
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedControllerRevision(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1ControllerRevision: ControllerRevision
    ): ControllerRevision {
        val iok8sapiappsv1ControllerRevisionLens = Body.auto<ControllerRevision>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}")
            .with(iok8sapiappsv1ControllerRevisionLens of iok8sapiappsv1ControllerRevision)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ControllerRevisionLens(response)
    }

    /**
     * delete collection of DaemonSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAppsV1CollectionNamespacedDaemonSet(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/daemonsets")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind DaemonSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1NamespacedDaemonSet(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): DaemonSetList {
        val iok8sapiappsv1DaemonSetListLens = Body.auto<DaemonSetList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/daemonsets")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DaemonSetListLens(response)
    }

    /**
     * create a DaemonSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAppsV1NamespacedDaemonSet(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1DaemonSet: DaemonSet
    ): DaemonSet {
        val iok8sapiappsv1DaemonSetLens = Body.auto<DaemonSet>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/apps/v1/namespaces/{namespace}/daemonsets")
            .with(iok8sapiappsv1DaemonSetLens of iok8sapiappsv1DaemonSet)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DaemonSetLens(response)
    }

    /**
     * delete a DaemonSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAppsV1NamespacedDaemonSet(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified DaemonSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedDaemonSet(
        name: String,
        namespace: String,
        pretty: String? = null
    ): DaemonSet {
        val iok8sapiappsv1DaemonSetLens = Body.auto<DaemonSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DaemonSetLens(response)
    }

    /**
     * partially update the specified DaemonSet
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedDaemonSet(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): DaemonSet {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiappsv1DaemonSetLens = Body.auto<DaemonSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DaemonSetLens(response)
    }

    /**
     * replace the specified DaemonSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedDaemonSet(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1DaemonSet: DaemonSet
    ): DaemonSet {
        val iok8sapiappsv1DaemonSetLens = Body.auto<DaemonSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}")
            .with(iok8sapiappsv1DaemonSetLens of iok8sapiappsv1DaemonSet)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DaemonSetLens(response)
    }

    /**
     * read status of the specified DaemonSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedDaemonSetStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): DaemonSet {
        val iok8sapiappsv1DaemonSetLens = Body.auto<DaemonSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DaemonSetLens(response)
    }

    /**
     * partially update status of the specified DaemonSet
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedDaemonSetStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): DaemonSet {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiappsv1DaemonSetLens = Body.auto<DaemonSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DaemonSetLens(response)
    }

    /**
     * replace status of the specified DaemonSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedDaemonSetStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1DaemonSet: DaemonSet
    ): DaemonSet {
        val iok8sapiappsv1DaemonSetLens = Body.auto<DaemonSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status")
            .with(iok8sapiappsv1DaemonSetLens of iok8sapiappsv1DaemonSet)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DaemonSetLens(response)
    }

    /**
     * delete collection of Deployment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAppsV1CollectionNamespacedDeployment(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/deployments")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Deployment
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1NamespacedDeployment(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): DeploymentList {
        val iok8sapiappsv1DeploymentListLens = Body.auto<DeploymentList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/deployments")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DeploymentListLens(response)
    }

    /**
     * create a Deployment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAppsV1NamespacedDeployment(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1Deployment: Deployment
    ): Deployment {
        val iok8sapiappsv1DeploymentLens = Body.auto<Deployment>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/apps/v1/namespaces/{namespace}/deployments")
            .with(iok8sapiappsv1DeploymentLens of iok8sapiappsv1Deployment)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DeploymentLens(response)
    }

    /**
     * delete a Deployment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAppsV1NamespacedDeployment(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Deployment
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedDeployment(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Deployment {
        val iok8sapiappsv1DeploymentLens = Body.auto<Deployment>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DeploymentLens(response)
    }

    /**
     * partially update the specified Deployment
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedDeployment(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Deployment {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiappsv1DeploymentLens = Body.auto<Deployment>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DeploymentLens(response)
    }

    /**
     * replace the specified Deployment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedDeployment(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1Deployment: Deployment
    ): Deployment {
        val iok8sapiappsv1DeploymentLens = Body.auto<Deployment>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}")
            .with(iok8sapiappsv1DeploymentLens of iok8sapiappsv1Deployment)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DeploymentLens(response)
    }

    /**
     * read scale of the specified Deployment
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedDeploymentScale(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Scale {
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * partially update scale of the specified Deployment
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedDeploymentScale(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Scale {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * replace scale of the specified Deployment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedDeploymentScale(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv1Scale: Scale
    ): Scale {
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale")
            .with(iok8sapiautoscalingv1ScaleLens of iok8sapiautoscalingv1Scale)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * read status of the specified Deployment
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedDeploymentStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Deployment {
        val iok8sapiappsv1DeploymentLens = Body.auto<Deployment>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DeploymentLens(response)
    }

    /**
     * partially update status of the specified Deployment
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedDeploymentStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Deployment {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiappsv1DeploymentLens = Body.auto<Deployment>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DeploymentLens(response)
    }

    /**
     * replace status of the specified Deployment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedDeploymentStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1Deployment: Deployment
    ): Deployment {
        val iok8sapiappsv1DeploymentLens = Body.auto<Deployment>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status")
            .with(iok8sapiappsv1DeploymentLens of iok8sapiappsv1Deployment)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1DeploymentLens(response)
    }

    /**
     * delete collection of ReplicaSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAppsV1CollectionNamespacedReplicaSet(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/replicasets")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ReplicaSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1NamespacedReplicaSet(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ReplicaSetList {
        val iok8sapiappsv1ReplicaSetListLens = Body.auto<ReplicaSetList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/replicasets")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ReplicaSetListLens(response)
    }

    /**
     * create a ReplicaSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAppsV1NamespacedReplicaSet(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1ReplicaSet: ReplicaSet
    ): ReplicaSet {
        val iok8sapiappsv1ReplicaSetLens = Body.auto<ReplicaSet>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/apps/v1/namespaces/{namespace}/replicasets")
            .with(iok8sapiappsv1ReplicaSetLens of iok8sapiappsv1ReplicaSet)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ReplicaSetLens(response)
    }

    /**
     * delete a ReplicaSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAppsV1NamespacedReplicaSet(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ReplicaSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedReplicaSet(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ReplicaSet {
        val iok8sapiappsv1ReplicaSetLens = Body.auto<ReplicaSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ReplicaSetLens(response)
    }

    /**
     * partially update the specified ReplicaSet
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedReplicaSet(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ReplicaSet {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiappsv1ReplicaSetLens = Body.auto<ReplicaSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ReplicaSetLens(response)
    }

    /**
     * replace the specified ReplicaSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedReplicaSet(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1ReplicaSet: ReplicaSet
    ): ReplicaSet {
        val iok8sapiappsv1ReplicaSetLens = Body.auto<ReplicaSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}")
            .with(iok8sapiappsv1ReplicaSetLens of iok8sapiappsv1ReplicaSet)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ReplicaSetLens(response)
    }

    /**
     * read scale of the specified ReplicaSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedReplicaSetScale(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Scale {
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * partially update scale of the specified ReplicaSet
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedReplicaSetScale(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Scale {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * replace scale of the specified ReplicaSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedReplicaSetScale(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv1Scale: Scale
    ): Scale {
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale")
            .with(iok8sapiautoscalingv1ScaleLens of iok8sapiautoscalingv1Scale)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * read status of the specified ReplicaSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedReplicaSetStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ReplicaSet {
        val iok8sapiappsv1ReplicaSetLens = Body.auto<ReplicaSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ReplicaSetLens(response)
    }

    /**
     * partially update status of the specified ReplicaSet
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedReplicaSetStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ReplicaSet {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiappsv1ReplicaSetLens = Body.auto<ReplicaSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ReplicaSetLens(response)
    }

    /**
     * replace status of the specified ReplicaSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedReplicaSetStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1ReplicaSet: ReplicaSet
    ): ReplicaSet {
        val iok8sapiappsv1ReplicaSetLens = Body.auto<ReplicaSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status")
            .with(iok8sapiappsv1ReplicaSetLens of iok8sapiappsv1ReplicaSet)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ReplicaSetLens(response)
    }

    /**
     * delete collection of StatefulSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAppsV1CollectionNamespacedStatefulSet(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/statefulsets")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind StatefulSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1NamespacedStatefulSet(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): StatefulSetList {
        val iok8sapiappsv1StatefulSetListLens = Body.auto<StatefulSetList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/statefulsets")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1StatefulSetListLens(response)
    }

    /**
     * create a StatefulSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAppsV1NamespacedStatefulSet(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1StatefulSet: StatefulSet
    ): StatefulSet {
        val iok8sapiappsv1StatefulSetLens = Body.auto<StatefulSet>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/apps/v1/namespaces/{namespace}/statefulsets")
            .with(iok8sapiappsv1StatefulSetLens of iok8sapiappsv1StatefulSet)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1StatefulSetLens(response)
    }

    /**
     * delete a StatefulSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAppsV1NamespacedStatefulSet(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified StatefulSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedStatefulSet(
        name: String,
        namespace: String,
        pretty: String? = null
    ): StatefulSet {
        val iok8sapiappsv1StatefulSetLens = Body.auto<StatefulSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1StatefulSetLens(response)
    }

    /**
     * partially update the specified StatefulSet
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedStatefulSet(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): StatefulSet {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiappsv1StatefulSetLens = Body.auto<StatefulSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1StatefulSetLens(response)
    }

    /**
     * replace the specified StatefulSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedStatefulSet(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1StatefulSet: StatefulSet
    ): StatefulSet {
        val iok8sapiappsv1StatefulSetLens = Body.auto<StatefulSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}")
            .with(iok8sapiappsv1StatefulSetLens of iok8sapiappsv1StatefulSet)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1StatefulSetLens(response)
    }

    /**
     * read scale of the specified StatefulSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedStatefulSetScale(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Scale {
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * partially update scale of the specified StatefulSet
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedStatefulSetScale(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Scale {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * replace scale of the specified StatefulSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedStatefulSetScale(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv1Scale: Scale
    ): Scale {
        val iok8sapiautoscalingv1ScaleLens = Body.auto<Scale>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale")
            .with(iok8sapiautoscalingv1ScaleLens of iok8sapiautoscalingv1Scale)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1ScaleLens(response)
    }

    /**
     * read status of the specified StatefulSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAppsV1NamespacedStatefulSetStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): StatefulSet {
        val iok8sapiappsv1StatefulSetLens = Body.auto<StatefulSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1StatefulSetLens(response)
    }

    /**
     * partially update status of the specified StatefulSet
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAppsV1NamespacedStatefulSetStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): StatefulSet {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiappsv1StatefulSetLens = Body.auto<StatefulSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1StatefulSetLens(response)
    }

    /**
     * replace status of the specified StatefulSet
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAppsV1NamespacedStatefulSetStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiappsv1StatefulSet: StatefulSet
    ): StatefulSet {
        val iok8sapiappsv1StatefulSetLens = Body.auto<StatefulSet>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status")
            .with(iok8sapiappsv1StatefulSetLens of iok8sapiappsv1StatefulSet)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1StatefulSetLens(response)
    }

    /**
     * list or watch objects of kind ReplicaSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1ReplicaSetForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ReplicaSetList {
        val iok8sapiappsv1ReplicaSetListLens = Body.auto<ReplicaSetList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/replicasets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1ReplicaSetListLens(response)
    }

    /**
     * list or watch objects of kind StatefulSet
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAppsV1StatefulSetForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): StatefulSetList {
        val iok8sapiappsv1StatefulSetListLens = Body.auto<StatefulSetList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/statefulsets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiappsv1StatefulSetListLens(response)
    }

    /**
     * watch individual changes to a list of ControllerRevision. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1ControllerRevisionListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/controllerrevisions")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of DaemonSet. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1DaemonSetListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/daemonsets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Deployment. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1DeploymentListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/deployments")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ControllerRevision. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedControllerRevisionList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ControllerRevision. deprecated: use the 'watch' parameter
     * with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedControllerRevision(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of DaemonSet. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedDaemonSetList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/daemonsets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind DaemonSet. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedDaemonSet(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/daemonsets/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Deployment. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedDeploymentList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/deployments")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Deployment. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedDeployment(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ReplicaSet. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedReplicaSetList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/replicasets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ReplicaSet. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedReplicaSet(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/replicasets/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of StatefulSet. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedStatefulSetList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/statefulsets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind StatefulSet. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1NamespacedStatefulSet(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/namespaces/{namespace}/statefulsets/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ReplicaSet. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1ReplicaSetListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/replicasets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of StatefulSet. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAppsV1StatefulSetListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/apps/v1/watch/statefulsets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAuthenticationAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/authentication.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAuthenticationV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/authentication.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * create a TokenReview
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAuthenticationV1TokenReview(
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapiauthenticationv1TokenReview: TokenReview
    ): TokenReview {
        val iok8sapiauthenticationv1TokenReviewLens = Body.auto<TokenReview>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.POST, "/apis/authentication.k8s.io/v1/tokenreviews")
            .with(iok8sapiauthenticationv1TokenReviewLens of iok8sapiauthenticationv1TokenReview)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiauthenticationv1TokenReviewLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAuthenticationV1alpha1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/authentication.k8s.io/v1alpha1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * create a SelfSubjectReview
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAuthenticationV1alpha1SelfSubjectReview(
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapiauthenticationv1alpha1SelfSubjectReview: SelfSubjectReview
    ): SelfSubjectReview {
        val iok8sapiauthenticationv1alpha1SelfSubjectReviewLens = Body.auto<SelfSubjectReview>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.POST, "/apis/authentication.k8s.io/v1alpha1/selfsubjectreviews")
            .with(iok8sapiauthenticationv1alpha1SelfSubjectReviewLens of iok8sapiauthenticationv1alpha1SelfSubjectReview)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiauthenticationv1alpha1SelfSubjectReviewLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAuthorizationAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/authorization.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAuthorizationV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/authorization.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * create a LocalSubjectAccessReview
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAuthorizationV1NamespacedLocalSubjectAccessReview(
        namespace: String,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapiauthorizationv1LocalSubjectAccessReview: LocalSubjectAccessReview
    ): LocalSubjectAccessReview {
        val iok8sapiauthorizationv1LocalSubjectAccessReviewLens =
            Body.auto<LocalSubjectAccessReview>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.POST, "/apis/authorization.k8s.io/v1/namespaces/{namespace}/localsubjectaccessreviews")
                .with(iok8sapiauthorizationv1LocalSubjectAccessReviewLens of iok8sapiauthorizationv1LocalSubjectAccessReview)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiauthorizationv1LocalSubjectAccessReviewLens(response)
    }

    /**
     * create a SelfSubjectAccessReview
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAuthorizationV1SelfSubjectAccessReview(
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapiauthorizationv1SelfSubjectAccessReview: SelfSubjectAccessReview
    ): SelfSubjectAccessReview {
        val iok8sapiauthorizationv1SelfSubjectAccessReviewLens =
            Body.auto<SelfSubjectAccessReview>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.POST, "/apis/authorization.k8s.io/v1/selfsubjectaccessreviews")
            .with(iok8sapiauthorizationv1SelfSubjectAccessReviewLens of iok8sapiauthorizationv1SelfSubjectAccessReview)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiauthorizationv1SelfSubjectAccessReviewLens(response)
    }

    /**
     * create a SelfSubjectRulesReview
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAuthorizationV1SelfSubjectRulesReview(
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapiauthorizationv1SelfSubjectRulesReview: SelfSubjectRulesReview
    ): SelfSubjectRulesReview {
        val iok8sapiauthorizationv1SelfSubjectRulesReviewLens =
            Body.auto<SelfSubjectRulesReview>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.POST, "/apis/authorization.k8s.io/v1/selfsubjectrulesreviews")
            .with(iok8sapiauthorizationv1SelfSubjectRulesReviewLens of iok8sapiauthorizationv1SelfSubjectRulesReview)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiauthorizationv1SelfSubjectRulesReviewLens(response)
    }

    /**
     * create a SubjectAccessReview
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAuthorizationV1SubjectAccessReview(
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        pretty: String? = null,
        iok8sapiauthorizationv1SubjectAccessReview: SubjectAccessReview
    ): SubjectAccessReview {
        val iok8sapiauthorizationv1SubjectAccessReviewLens = Body.auto<SubjectAccessReview>().toLens()
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.POST, "/apis/authorization.k8s.io/v1/subjectaccessreviews")
            .with(iok8sapiauthorizationv1SubjectAccessReviewLens of iok8sapiauthorizationv1SubjectAccessReview)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiauthorizationv1SubjectAccessReviewLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAutoscalingAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/autoscaling/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAutoscalingV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/autoscaling/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): HorizontalPodAutoscalerList {
        val iok8sapiautoscalingv1HorizontalPodAutoscalerListLens =
            Body.auto<HorizontalPodAutoscalerList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v1/horizontalpodautoscalers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1HorizontalPodAutoscalerListLens(response)
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAutoscalingV1NamespacedHorizontalPodAutoscaler(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): HorizontalPodAutoscalerList {
        val iok8sapiautoscalingv1HorizontalPodAutoscalerListLens =
            Body.auto<HorizontalPodAutoscalerList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1HorizontalPodAutoscalerListLens(response)
    }

    /**
     * create a HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAutoscalingV1NamespacedHorizontalPodAutoscaler(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv1HorizontalPodAutoscaler: HorizontalPodAutoscaler
    ): HorizontalPodAutoscaler {
        val iok8sapiautoscalingv1HorizontalPodAutoscalerLens =
            Body.auto<HorizontalPodAutoscaler>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers")
            .with(iok8sapiautoscalingv1HorizontalPodAutoscalerLens of iok8sapiautoscalingv1HorizontalPodAutoscaler)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1HorizontalPodAutoscalerLens(response)
    }

    /**
     * delete a HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAutoscalingV1NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAutoscalingV1NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        pretty: String? = null
    ): HorizontalPodAutoscaler {
        val iok8sapiautoscalingv1HorizontalPodAutoscalerLens =
            Body.auto<HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1HorizontalPodAutoscalerLens(response)
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAutoscalingV1NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): HorizontalPodAutoscaler {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiautoscalingv1HorizontalPodAutoscalerLens =
            Body.auto<HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1HorizontalPodAutoscalerLens(response)
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAutoscalingV1NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv1HorizontalPodAutoscaler: HorizontalPodAutoscaler
    ): HorizontalPodAutoscaler {
        val iok8sapiautoscalingv1HorizontalPodAutoscalerLens =
            Body.auto<HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}")
            .with(iok8sapiautoscalingv1HorizontalPodAutoscalerLens of iok8sapiautoscalingv1HorizontalPodAutoscaler)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1HorizontalPodAutoscalerLens(response)
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): HorizontalPodAutoscaler {
        val iok8sapiautoscalingv1HorizontalPodAutoscalerLens =
            Body.auto<HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status")
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1HorizontalPodAutoscalerLens(response)
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): HorizontalPodAutoscaler {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiautoscalingv1HorizontalPodAutoscalerLens =
            Body.auto<HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1HorizontalPodAutoscalerLens(response)
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv1HorizontalPodAutoscaler: HorizontalPodAutoscaler
    ): HorizontalPodAutoscaler {
        val iok8sapiautoscalingv1HorizontalPodAutoscalerLens =
            Body.auto<HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status")
                .with(iok8sapiautoscalingv1HorizontalPodAutoscalerLens of iok8sapiautoscalingv1HorizontalPodAutoscaler)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv1HorizontalPodAutoscalerLens(response)
    }

    /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v1/watch/horizontalpodautoscalers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAutoscalingV1NamespacedHorizontalPodAutoscalerList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAutoscalingV1NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getAutoscalingV2APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/autoscaling/v2/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAutoscalingV2HorizontalPodAutoscalerForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerList {
        val iok8sapiautoscalingv2HorizontalPodAutoscalerListLens =
            Body.auto<http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v2/horizontalpodautoscalers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv2HorizontalPodAutoscalerListLens(response)
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteAutoscalingV2CollectionNamespacedHorizontalPodAutoscaler(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listAutoscalingV2NamespacedHorizontalPodAutoscaler(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerList {
        val iok8sapiautoscalingv2HorizontalPodAutoscalerListLens =
            Body.auto<http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscalerList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv2HorizontalPodAutoscalerListLens(response)
    }

    /**
     * create a HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createAutoscalingV2NamespacedHorizontalPodAutoscaler(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv2HorizontalPodAutoscaler: http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler
    ): http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler {
        val iok8sapiautoscalingv2HorizontalPodAutoscalerLens =
            Body.auto<http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers")
            .with(iok8sapiautoscalingv2HorizontalPodAutoscalerLens of iok8sapiautoscalingv2HorizontalPodAutoscaler)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv2HorizontalPodAutoscalerLens(response)
    }

    /**
     * delete a HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteAutoscalingV2NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAutoscalingV2NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        pretty: String? = null
    ): http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler {
        val iok8sapiautoscalingv2HorizontalPodAutoscalerLens =
            Body.auto<http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv2HorizontalPodAutoscalerLens(response)
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAutoscalingV2NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiautoscalingv2HorizontalPodAutoscalerLens =
            Body.auto<http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv2HorizontalPodAutoscalerLens(response)
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAutoscalingV2NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv2HorizontalPodAutoscaler: http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler
    ): http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler {
        val iok8sapiautoscalingv2HorizontalPodAutoscalerLens =
            Body.auto<http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}")
            .with(iok8sapiautoscalingv2HorizontalPodAutoscalerLens of iok8sapiautoscalingv2HorizontalPodAutoscaler)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv2HorizontalPodAutoscalerLens(response)
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readAutoscalingV2NamespacedHorizontalPodAutoscalerStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler {
        val iok8sapiautoscalingv2HorizontalPodAutoscalerLens =
            Body.auto<http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status")
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv2HorizontalPodAutoscalerLens(response)
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchAutoscalingV2NamespacedHorizontalPodAutoscalerStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiautoscalingv2HorizontalPodAutoscalerLens =
            Body.auto<http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv2HorizontalPodAutoscalerLens(response)
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceAutoscalingV2NamespacedHorizontalPodAutoscalerStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiautoscalingv2HorizontalPodAutoscaler: http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler
    ): http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler {
        val iok8sapiautoscalingv2HorizontalPodAutoscalerLens =
            Body.auto<http4k.k8s.model.io.k8s.api.autoscaling.v2.HorizontalPodAutoscaler>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status")
                .with(iok8sapiautoscalingv2HorizontalPodAutoscalerLens of iok8sapiautoscalingv2HorizontalPodAutoscaler)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiautoscalingv2HorizontalPodAutoscalerLens(response)
    }

    /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAutoscalingV2HorizontalPodAutoscalerListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v2/watch/horizontalpodautoscalers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAutoscalingV2NamespacedHorizontalPodAutoscalerList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/autoscaling/v2/watch/namespaces/{namespace}/horizontalpodautoscalers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchAutoscalingV2NamespacedHorizontalPodAutoscaler(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/autoscaling/v2/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getBatchAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/batch/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getBatchV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/batch/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * list or watch objects of kind CronJob
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listBatchV1CronJobForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): CronJobList {
        val iok8sapibatchv1CronJobListLens = Body.auto<CronJobList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/cronjobs")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1CronJobListLens(response)
    }

    /**
     * list or watch objects of kind Job
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listBatchV1JobForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): JobList {
        val iok8sapibatchv1JobListLens = Body.auto<JobList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/jobs")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1JobListLens(response)
    }

    /**
     * delete collection of CronJob
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteBatchV1CollectionNamespacedCronJob(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/batch/v1/namespaces/{namespace}/cronjobs")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind CronJob
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listBatchV1NamespacedCronJob(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): CronJobList {
        val iok8sapibatchv1CronJobListLens = Body.auto<CronJobList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/namespaces/{namespace}/cronjobs")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1CronJobListLens(response)
    }

    /**
     * create a CronJob
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createBatchV1NamespacedCronJob(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapibatchv1CronJob: CronJob
    ): CronJob {
        val iok8sapibatchv1CronJobLens = Body.auto<CronJob>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/batch/v1/namespaces/{namespace}/cronjobs")
            .with(iok8sapibatchv1CronJobLens of iok8sapibatchv1CronJob)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1CronJobLens(response)
    }

    /**
     * delete a CronJob
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteBatchV1NamespacedCronJob(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified CronJob
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readBatchV1NamespacedCronJob(
        name: String,
        namespace: String,
        pretty: String? = null
    ): CronJob {
        val iok8sapibatchv1CronJobLens = Body.auto<CronJob>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1CronJobLens(response)
    }

    /**
     * partially update the specified CronJob
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchBatchV1NamespacedCronJob(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CronJob {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapibatchv1CronJobLens = Body.auto<CronJob>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1CronJobLens(response)
    }

    /**
     * replace the specified CronJob
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceBatchV1NamespacedCronJob(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapibatchv1CronJob: CronJob
    ): CronJob {
        val iok8sapibatchv1CronJobLens = Body.auto<CronJob>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}")
            .with(iok8sapibatchv1CronJobLens of iok8sapibatchv1CronJob)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1CronJobLens(response)
    }

    /**
     * read status of the specified CronJob
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readBatchV1NamespacedCronJobStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): CronJob {
        val iok8sapibatchv1CronJobLens = Body.auto<CronJob>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1CronJobLens(response)
    }

    /**
     * partially update status of the specified CronJob
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchBatchV1NamespacedCronJobStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CronJob {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapibatchv1CronJobLens = Body.auto<CronJob>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1CronJobLens(response)
    }

    /**
     * replace status of the specified CronJob
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceBatchV1NamespacedCronJobStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapibatchv1CronJob: CronJob
    ): CronJob {
        val iok8sapibatchv1CronJobLens = Body.auto<CronJob>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status")
            .with(iok8sapibatchv1CronJobLens of iok8sapibatchv1CronJob)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1CronJobLens(response)
    }

    /**
     * delete collection of Job
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteBatchV1CollectionNamespacedJob(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/batch/v1/namespaces/{namespace}/jobs")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Job
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listBatchV1NamespacedJob(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): JobList {
        val iok8sapibatchv1JobListLens = Body.auto<JobList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/namespaces/{namespace}/jobs")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1JobListLens(response)
    }

    /**
     * create a Job
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createBatchV1NamespacedJob(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapibatchv1Job: Job
    ): Job {
        val iok8sapibatchv1JobLens = Body.auto<Job>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/batch/v1/namespaces/{namespace}/jobs")
            .with(iok8sapibatchv1JobLens of iok8sapibatchv1Job)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1JobLens(response)
    }

    /**
     * delete a Job
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteBatchV1NamespacedJob(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/batch/v1/namespaces/{namespace}/jobs/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Job
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readBatchV1NamespacedJob(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Job {
        val iok8sapibatchv1JobLens = Body.auto<Job>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/batch/v1/namespaces/{namespace}/jobs/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1JobLens(response)
    }

    /**
     * partially update the specified Job
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchBatchV1NamespacedJob(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Job {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapibatchv1JobLens = Body.auto<Job>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/batch/v1/namespaces/{namespace}/jobs/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1JobLens(response)
    }

    /**
     * replace the specified Job
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceBatchV1NamespacedJob(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapibatchv1Job: Job
    ): Job {
        val iok8sapibatchv1JobLens = Body.auto<Job>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/batch/v1/namespaces/{namespace}/jobs/{name}")
            .with(iok8sapibatchv1JobLens of iok8sapibatchv1Job)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1JobLens(response)
    }

    /**
     * read status of the specified Job
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readBatchV1NamespacedJobStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Job {
        val iok8sapibatchv1JobLens = Body.auto<Job>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1JobLens(response)
    }

    /**
     * partially update status of the specified Job
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchBatchV1NamespacedJobStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Job {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapibatchv1JobLens = Body.auto<Job>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1JobLens(response)
    }

    /**
     * replace status of the specified Job
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceBatchV1NamespacedJobStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapibatchv1Job: Job
    ): Job {
        val iok8sapibatchv1JobLens = Body.auto<Job>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status")
            .with(iok8sapibatchv1JobLens of iok8sapibatchv1Job)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapibatchv1JobLens(response)
    }

    /**
     * watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchBatchV1CronJobListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/watch/cronjobs")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Job. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchBatchV1JobListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/watch/jobs")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchBatchV1NamespacedCronJobList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/watch/namespaces/{namespace}/cronjobs")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind CronJob. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchBatchV1NamespacedCronJob(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/watch/namespaces/{namespace}/cronjobs/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Job. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchBatchV1NamespacedJobList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/watch/namespaces/{namespace}/jobs")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Job. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchBatchV1NamespacedJob(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/batch/v1/watch/namespaces/{namespace}/jobs/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getCertificatesAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/certificates.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getCertificatesV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/certificates.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of CertificateSigningRequest
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCertificatesV1CollectionCertificateSigningRequest(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/certificates.k8s.io/v1/certificatesigningrequests")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind CertificateSigningRequest
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCertificatesV1CertificateSigningRequest(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): CertificateSigningRequestList {
        val iok8sapicertificatesv1CertificateSigningRequestListLens =
            Body.auto<CertificateSigningRequestList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/certificates.k8s.io/v1/certificatesigningrequests")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestListLens(response)
    }

    /**
     * create a CertificateSigningRequest
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCertificatesV1CertificateSigningRequest(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicertificatesv1CertificateSigningRequest: CertificateSigningRequest
    ): CertificateSigningRequest {
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/certificates.k8s.io/v1/certificatesigningrequests")
            .with(iok8sapicertificatesv1CertificateSigningRequestLens of iok8sapicertificatesv1CertificateSigningRequest)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * delete a CertificateSigningRequest
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCertificatesV1CertificateSigningRequest(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified CertificateSigningRequest
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCertificatesV1CertificateSigningRequest(name: String, pretty: String? = null):
        CertificateSigningRequest {
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * partially update the specified CertificateSigningRequest
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCertificatesV1CertificateSigningRequest(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CertificateSigningRequest {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * replace the specified CertificateSigningRequest
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCertificatesV1CertificateSigningRequest(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicertificatesv1CertificateSigningRequest: CertificateSigningRequest
    ): CertificateSigningRequest {
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}")
            .with(iok8sapicertificatesv1CertificateSigningRequestLens of iok8sapicertificatesv1CertificateSigningRequest)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * read approval of the specified CertificateSigningRequest
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCertificatesV1CertificateSigningRequestApproval(
        name: String, pretty: String? =
            null
    ): CertificateSigningRequest {
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * partially update approval of the specified CertificateSigningRequest
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCertificatesV1CertificateSigningRequestApproval(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CertificateSigningRequest {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * replace approval of the specified CertificateSigningRequest
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCertificatesV1CertificateSigningRequestApproval(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicertificatesv1CertificateSigningRequest: CertificateSigningRequest
    ): CertificateSigningRequest {
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval")
            .with(iok8sapicertificatesv1CertificateSigningRequestLens of iok8sapicertificatesv1CertificateSigningRequest)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * read status of the specified CertificateSigningRequest
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCertificatesV1CertificateSigningRequestStatus(name: String, pretty: String? = null):
        CertificateSigningRequest {
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * partially update status of the specified CertificateSigningRequest
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCertificatesV1CertificateSigningRequestStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CertificateSigningRequest {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * replace status of the specified CertificateSigningRequest
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCertificatesV1CertificateSigningRequestStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicertificatesv1CertificateSigningRequest: CertificateSigningRequest
    ): CertificateSigningRequest {
        val iok8sapicertificatesv1CertificateSigningRequestLens =
            Body.auto<CertificateSigningRequest>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status")
            .with(iok8sapicertificatesv1CertificateSigningRequestLens of iok8sapicertificatesv1CertificateSigningRequest)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicertificatesv1CertificateSigningRequestLens(response)
    }

    /**
     * watch individual changes to a list of CertificateSigningRequest. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCertificatesV1CertificateSigningRequestList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/certificates.k8s.io/v1/watch/certificatesigningrequests")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind CertificateSigningRequest. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCertificatesV1CertificateSigningRequest(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/certificates.k8s.io/v1/watch/certificatesigningrequests/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getCoordinationAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/coordination.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getCoordinationV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/coordination.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * list or watch objects of kind Lease
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoordinationV1LeaseForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): LeaseList {
        val iok8sapicoordinationv1LeaseListLens = Body.auto<LeaseList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/coordination.k8s.io/v1/leases")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicoordinationv1LeaseListLens(response)
    }

    /**
     * delete collection of Lease
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteCoordinationV1CollectionNamespacedLease(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Lease
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listCoordinationV1NamespacedLease(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): LeaseList {
        val iok8sapicoordinationv1LeaseListLens = Body.auto<LeaseList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicoordinationv1LeaseListLens(response)
    }

    /**
     * create a Lease
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createCoordinationV1NamespacedLease(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicoordinationv1Lease: Lease
    ): Lease {
        val iok8sapicoordinationv1LeaseLens = Body.auto<Lease>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases")
            .with(iok8sapicoordinationv1LeaseLens of iok8sapicoordinationv1Lease)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicoordinationv1LeaseLens(response)
    }

    /**
     * delete a Lease
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteCoordinationV1NamespacedLease(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Lease
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readCoordinationV1NamespacedLease(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Lease {
        val iok8sapicoordinationv1LeaseLens = Body.auto<Lease>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicoordinationv1LeaseLens(response)
    }

    /**
     * partially update the specified Lease
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchCoordinationV1NamespacedLease(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Lease {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapicoordinationv1LeaseLens = Body.auto<Lease>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicoordinationv1LeaseLens(response)
    }

    /**
     * replace the specified Lease
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceCoordinationV1NamespacedLease(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapicoordinationv1Lease: Lease
    ): Lease {
        val iok8sapicoordinationv1LeaseLens = Body.auto<Lease>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}")
            .with(iok8sapicoordinationv1LeaseLens of iok8sapicoordinationv1Lease)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapicoordinationv1LeaseLens(response)
    }

    /**
     * watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoordinationV1LeaseListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/coordination.k8s.io/v1/watch/leases")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoordinationV1NamespacedLeaseList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Lease. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchCoordinationV1NamespacedLease(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getDiscoveryAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/discovery.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getDiscoveryV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/discovery.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * list or watch objects of kind EndpointSlice
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listDiscoveryV1EndpointSliceForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): EndpointSliceList {
        val iok8sapidiscoveryv1EndpointSliceListLens = Body.auto<EndpointSliceList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/discovery.k8s.io/v1/endpointslices")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapidiscoveryv1EndpointSliceListLens(response)
    }

    /**
     * delete collection of EndpointSlice
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteDiscoveryV1CollectionNamespacedEndpointSlice(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind EndpointSlice
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listDiscoveryV1NamespacedEndpointSlice(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): EndpointSliceList {
        val iok8sapidiscoveryv1EndpointSliceListLens = Body.auto<EndpointSliceList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapidiscoveryv1EndpointSliceListLens(response)
    }

    /**
     * create an EndpointSlice
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createDiscoveryV1NamespacedEndpointSlice(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapidiscoveryv1EndpointSlice: EndpointSlice
    ): EndpointSlice {
        val iok8sapidiscoveryv1EndpointSliceLens = Body.auto<EndpointSlice>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices")
            .with(iok8sapidiscoveryv1EndpointSliceLens of iok8sapidiscoveryv1EndpointSlice)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapidiscoveryv1EndpointSliceLens(response)
    }

    /**
     * delete an EndpointSlice
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteDiscoveryV1NamespacedEndpointSlice(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified EndpointSlice
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readDiscoveryV1NamespacedEndpointSlice(
        name: String,
        namespace: String,
        pretty: String? = null
    ): EndpointSlice {
        val iok8sapidiscoveryv1EndpointSliceLens = Body.auto<EndpointSlice>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapidiscoveryv1EndpointSliceLens(response)
    }

    /**
     * partially update the specified EndpointSlice
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchDiscoveryV1NamespacedEndpointSlice(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): EndpointSlice {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapidiscoveryv1EndpointSliceLens = Body.auto<EndpointSlice>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapidiscoveryv1EndpointSliceLens(response)
    }

    /**
     * replace the specified EndpointSlice
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceDiscoveryV1NamespacedEndpointSlice(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapidiscoveryv1EndpointSlice: EndpointSlice
    ): EndpointSlice {
        val iok8sapidiscoveryv1EndpointSliceLens = Body.auto<EndpointSlice>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}")
            .with(iok8sapidiscoveryv1EndpointSliceLens of iok8sapidiscoveryv1EndpointSlice)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapidiscoveryv1EndpointSliceLens(response)
    }

    /**
     * watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchDiscoveryV1EndpointSliceListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/discovery.k8s.io/v1/watch/endpointslices")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchDiscoveryV1NamespacedEndpointSliceList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind EndpointSlice. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchDiscoveryV1NamespacedEndpointSlice(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getEventsAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/events.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getEventsV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/events.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * list or watch objects of kind Event
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listEventsV1EventForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): http4k.k8s.model.io.k8s.api.events.v1.EventList {
        val iok8sapieventsv1EventListLens =
            Body.auto<http4k.k8s.model.io.k8s.api.events.v1.EventList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/events.k8s.io/v1/events")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapieventsv1EventListLens(response)
    }

    /**
     * delete collection of Event
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteEventsV1CollectionNamespacedEvent(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/events.k8s.io/v1/namespaces/{namespace}/events")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Event
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listEventsV1NamespacedEvent(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): http4k.k8s.model.io.k8s.api.events.v1.EventList {
        val iok8sapieventsv1EventListLens =
            Body.auto<http4k.k8s.model.io.k8s.api.events.v1.EventList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/events.k8s.io/v1/namespaces/{namespace}/events")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapieventsv1EventListLens(response)
    }

    /**
     * create an Event
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createEventsV1NamespacedEvent(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapieventsv1Event: http4k.k8s.model.io.k8s.api.events.v1.Event
    ): http4k.k8s.model.io.k8s.api.events.v1.Event {
        val iok8sapieventsv1EventLens = Body.auto<http4k.k8s.model.io.k8s.api.events.v1.Event>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/events.k8s.io/v1/namespaces/{namespace}/events")
            .with(iok8sapieventsv1EventLens of iok8sapieventsv1Event)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapieventsv1EventLens(response)
    }

    /**
     * delete an Event
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteEventsV1NamespacedEvent(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Event
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readEventsV1NamespacedEvent(
        name: String,
        namespace: String,
        pretty: String? = null
    ): http4k.k8s.model.io.k8s.api.events.v1.Event {
        val iok8sapieventsv1EventLens = Body.auto<http4k.k8s.model.io.k8s.api.events.v1.Event>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapieventsv1EventLens(response)
    }

    /**
     * partially update the specified Event
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchEventsV1NamespacedEvent(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): http4k.k8s.model.io.k8s.api.events.v1.Event {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapieventsv1EventLens = Body.auto<http4k.k8s.model.io.k8s.api.events.v1.Event>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapieventsv1EventLens(response)
    }

    /**
     * replace the specified Event
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceEventsV1NamespacedEvent(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapieventsv1Event: http4k.k8s.model.io.k8s.api.events.v1.Event
    ): http4k.k8s.model.io.k8s.api.events.v1.Event {
        val iok8sapieventsv1EventLens = Body.auto<http4k.k8s.model.io.k8s.api.events.v1.Event>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}")
            .with(iok8sapieventsv1EventLens of iok8sapieventsv1Event)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapieventsv1EventLens(response)
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchEventsV1EventListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/events.k8s.io/v1/watch/events")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchEventsV1NamespacedEventList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/events.k8s.io/v1/watch/namespaces/{namespace}/events")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchEventsV1NamespacedEvent(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/events.k8s.io/v1/watch/namespaces/{namespace}/events/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getFlowcontrolApiserverAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getFlowcontrolApiserverV1beta2APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteFlowcontrolApiserverV1beta2CollectionFlowSchema(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind FlowSchema
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listFlowcontrolApiserverV1beta2FlowSchema(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): FlowSchemaList {
        val iok8sapiflowcontrolv1beta2FlowSchemaListLens = Body.auto<FlowSchemaList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2FlowSchemaListLens(response)
    }

    /**
     * create a FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createFlowcontrolApiserverV1beta2FlowSchema(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta2FlowSchema: FlowSchema
    ): FlowSchema {
        val iok8sapiflowcontrolv1beta2FlowSchemaLens = Body.auto<FlowSchema>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas")
            .with(iok8sapiflowcontrolv1beta2FlowSchemaLens of iok8sapiflowcontrolv1beta2FlowSchema)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2FlowSchemaLens(response)
    }

    /**
     * delete a FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteFlowcontrolApiserverV1beta2FlowSchema(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified FlowSchema
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readFlowcontrolApiserverV1beta2FlowSchema(name: String, pretty: String? = null):
        FlowSchema {
        val iok8sapiflowcontrolv1beta2FlowSchemaLens = Body.auto<FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2FlowSchemaLens(response)
    }

    /**
     * partially update the specified FlowSchema
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchFlowcontrolApiserverV1beta2FlowSchema(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): FlowSchema {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiflowcontrolv1beta2FlowSchemaLens = Body.auto<FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2FlowSchemaLens(response)
    }

    /**
     * replace the specified FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceFlowcontrolApiserverV1beta2FlowSchema(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta2FlowSchema: FlowSchema
    ): FlowSchema {
        val iok8sapiflowcontrolv1beta2FlowSchemaLens = Body.auto<FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}")
            .with(iok8sapiflowcontrolv1beta2FlowSchemaLens of iok8sapiflowcontrolv1beta2FlowSchema)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2FlowSchemaLens(response)
    }

    /**
     * read status of the specified FlowSchema
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readFlowcontrolApiserverV1beta2FlowSchemaStatus(name: String, pretty: String? = null):
        FlowSchema {
        val iok8sapiflowcontrolv1beta2FlowSchemaLens = Body.auto<FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2FlowSchemaLens(response)
    }

    /**
     * partially update status of the specified FlowSchema
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchFlowcontrolApiserverV1beta2FlowSchemaStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): FlowSchema {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiflowcontrolv1beta2FlowSchemaLens = Body.auto<FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2FlowSchemaLens(response)
    }

    /**
     * replace status of the specified FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceFlowcontrolApiserverV1beta2FlowSchemaStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta2FlowSchema: FlowSchema
    ): FlowSchema {
        val iok8sapiflowcontrolv1beta2FlowSchemaLens = Body.auto<FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status")
            .with(iok8sapiflowcontrolv1beta2FlowSchemaLens of iok8sapiflowcontrolv1beta2FlowSchema)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2FlowSchemaLens(response)
    }

    /**
     * delete collection of PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteFlowcontrolApiserverV1beta2CollectionPriorityLevelConfiguration(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind PriorityLevelConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listFlowcontrolApiserverV1beta2PriorityLevelConfiguration(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PriorityLevelConfigurationList {
        val iok8sapiflowcontrolv1beta2PriorityLevelConfigurationListLens =
            Body.auto<PriorityLevelConfigurationList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2PriorityLevelConfigurationListLens(response)
    }

    /**
     * create a PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createFlowcontrolApiserverV1beta2PriorityLevelConfiguration(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta2PriorityLevelConfiguration: PriorityLevelConfiguration
    ): PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens =
            Body.auto<PriorityLevelConfiguration>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations")
            .with(iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens of iok8sapiflowcontrolv1beta2PriorityLevelConfiguration)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens(response)
    }

    /**
     * delete a PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteFlowcontrolApiserverV1beta2PriorityLevelConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified PriorityLevelConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readFlowcontrolApiserverV1beta2PriorityLevelConfiguration(
        name: String, pretty: String?
        = null
    ): PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens =
            Body.auto<PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}")
                .with(nameLens of name)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens(response)
    }

    /**
     * partially update the specified PriorityLevelConfiguration
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchFlowcontrolApiserverV1beta2PriorityLevelConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PriorityLevelConfiguration {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens =
            Body.auto<PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens(response)
    }

    /**
     * replace the specified PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceFlowcontrolApiserverV1beta2PriorityLevelConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta2PriorityLevelConfiguration: PriorityLevelConfiguration
    ): PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens =
            Body.auto<PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}")
                .with(iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens of iok8sapiflowcontrolv1beta2PriorityLevelConfiguration)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens(response)
    }

    /**
     * read status of the specified PriorityLevelConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus(
        name: String,
        pretty: String? = null
    ): PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens =
            Body.auto<PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status")
                .with(nameLens of name)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens(response)
    }

    /**
     * partially update status of the specified PriorityLevelConfiguration
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PriorityLevelConfiguration {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens =
            Body.auto<PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(
            Method.PATCH,
            "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status"
        )
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens(response)
    }

    /**
     * replace status of the specified PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceFlowcontrolApiserverV1beta2PriorityLevelConfigurationStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta2PriorityLevelConfiguration: PriorityLevelConfiguration
    ): PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens =
            Body.auto<PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status")
                .with(iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens of iok8sapiflowcontrolv1beta2PriorityLevelConfiguration)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta2PriorityLevelConfigurationLens(response)
    }

    /**
     * watch individual changes to a list of FlowSchema. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchFlowcontrolApiserverV1beta2FlowSchemaList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind FlowSchema. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchFlowcontrolApiserverV1beta2FlowSchema(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of PriorityLevelConfiguration. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchFlowcontrolApiserverV1beta2PriorityLevelConfigurationList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind PriorityLevelConfiguration. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchFlowcontrolApiserverV1beta2PriorityLevelConfiguration(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getFlowcontrolApiserverV1beta3APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteFlowcontrolApiserverV1beta3CollectionFlowSchema(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind FlowSchema
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listFlowcontrolApiserverV1beta3FlowSchema(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchemaList {
        val iok8sapiflowcontrolv1beta3FlowSchemaListLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchemaList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3FlowSchemaListLens(response)
    }

    /**
     * create a FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createFlowcontrolApiserverV1beta3FlowSchema(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta3FlowSchema: http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema {
        val iok8sapiflowcontrolv1beta3FlowSchemaLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas")
            .with(iok8sapiflowcontrolv1beta3FlowSchemaLens of iok8sapiflowcontrolv1beta3FlowSchema)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3FlowSchemaLens(response)
    }

    /**
     * delete a FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteFlowcontrolApiserverV1beta3FlowSchema(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified FlowSchema
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readFlowcontrolApiserverV1beta3FlowSchema(name: String, pretty: String? = null):
        http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema {
        val iok8sapiflowcontrolv1beta3FlowSchemaLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3FlowSchemaLens(response)
    }

    /**
     * partially update the specified FlowSchema
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchFlowcontrolApiserverV1beta3FlowSchema(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiflowcontrolv1beta3FlowSchemaLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3FlowSchemaLens(response)
    }

    /**
     * replace the specified FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceFlowcontrolApiserverV1beta3FlowSchema(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta3FlowSchema: http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema {
        val iok8sapiflowcontrolv1beta3FlowSchemaLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}")
            .with(iok8sapiflowcontrolv1beta3FlowSchemaLens of iok8sapiflowcontrolv1beta3FlowSchema)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3FlowSchemaLens(response)
    }

    /**
     * read status of the specified FlowSchema
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readFlowcontrolApiserverV1beta3FlowSchemaStatus(name: String, pretty: String? = null):
        http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema {
        val iok8sapiflowcontrolv1beta3FlowSchemaLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3FlowSchemaLens(response)
    }

    /**
     * partially update status of the specified FlowSchema
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchFlowcontrolApiserverV1beta3FlowSchemaStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiflowcontrolv1beta3FlowSchemaLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3FlowSchemaLens(response)
    }

    /**
     * replace status of the specified FlowSchema
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceFlowcontrolApiserverV1beta3FlowSchemaStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta3FlowSchema: http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema {
        val iok8sapiflowcontrolv1beta3FlowSchemaLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.FlowSchema>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}/status")
            .with(iok8sapiflowcontrolv1beta3FlowSchemaLens of iok8sapiflowcontrolv1beta3FlowSchema)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3FlowSchemaLens(response)
    }

    /**
     * delete collection of PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteFlowcontrolApiserverV1beta3CollectionPriorityLevelConfiguration(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind PriorityLevelConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listFlowcontrolApiserverV1beta3PriorityLevelConfiguration(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfigurationList {
        val iok8sapiflowcontrolv1beta3PriorityLevelConfigurationListLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfigurationList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3PriorityLevelConfigurationListLens(response)
    }

    /**
     * create a PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createFlowcontrolApiserverV1beta3PriorityLevelConfiguration(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta3PriorityLevelConfiguration: http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations")
            .with(iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens of iok8sapiflowcontrolv1beta3PriorityLevelConfiguration)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens(response)
    }

    /**
     * delete a PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteFlowcontrolApiserverV1beta3PriorityLevelConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified PriorityLevelConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readFlowcontrolApiserverV1beta3PriorityLevelConfiguration(
        name: String, pretty: String?
        = null
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}")
                .with(nameLens of name)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens(response)
    }

    /**
     * partially update the specified PriorityLevelConfiguration
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchFlowcontrolApiserverV1beta3PriorityLevelConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens(response)
    }

    /**
     * replace the specified PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceFlowcontrolApiserverV1beta3PriorityLevelConfiguration(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta3PriorityLevelConfiguration: http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}")
                .with(iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens of iok8sapiflowcontrolv1beta3PriorityLevelConfiguration)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens(response)
    }

    /**
     * read status of the specified PriorityLevelConfiguration
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readFlowcontrolApiserverV1beta3PriorityLevelConfigurationStatus(
        name: String,
        pretty: String? = null
    ):
        http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}/status")
                .with(nameLens of name)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens(response)
    }

    /**
     * partially update status of the specified PriorityLevelConfiguration
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchFlowcontrolApiserverV1beta3PriorityLevelConfigurationStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(
            Method.PATCH,
            "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}/status"
        )
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens(response)
    }

    /**
     * replace status of the specified PriorityLevelConfiguration
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceFlowcontrolApiserverV1beta3PriorityLevelConfigurationStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiflowcontrolv1beta3PriorityLevelConfiguration: http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration
    ): http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration {
        val iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens =
            Body.auto<http4k.k8s.model.io.k8s.api.flowcontrol.v1beta3.PriorityLevelConfiguration>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}/status")
                .with(iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens of iok8sapiflowcontrolv1beta3PriorityLevelConfiguration)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiflowcontrolv1beta3PriorityLevelConfigurationLens(response)
    }

    /**
     * watch individual changes to a list of FlowSchema. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchFlowcontrolApiserverV1beta3FlowSchemaList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/watch/flowschemas")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind FlowSchema. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchFlowcontrolApiserverV1beta3FlowSchema(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/watch/flowschemas/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of PriorityLevelConfiguration. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchFlowcontrolApiserverV1beta3PriorityLevelConfigurationList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/watch/prioritylevelconfigurations")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind PriorityLevelConfiguration. deprecated: use the 'watch'
     * parameter with a list operation instead, filtered to a single item with the 'fieldSelector'
     * parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchFlowcontrolApiserverV1beta3PriorityLevelConfiguration(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/flowcontrol.apiserver.k8s.io/v1beta3/watch/prioritylevelconfigurations/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getInternalApiserverAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/internal.apiserver.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getInternalApiserverV1alpha1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/internal.apiserver.k8s.io/v1alpha1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of StorageVersion
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteInternalApiserverV1alpha1CollectionStorageVersion(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind StorageVersion
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listInternalApiserverV1alpha1StorageVersion(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): StorageVersionList {
        val iok8sapiapiserverinternalv1alpha1StorageVersionListLens =
            Body.auto<StorageVersionList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiapiserverinternalv1alpha1StorageVersionListLens(response)
    }

    /**
     * create a StorageVersion
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createInternalApiserverV1alpha1StorageVersion(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiapiserverinternalv1alpha1StorageVersion: StorageVersion
    ): StorageVersion {
        val iok8sapiapiserverinternalv1alpha1StorageVersionLens = Body.auto<StorageVersion>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions")
            .with(iok8sapiapiserverinternalv1alpha1StorageVersionLens of iok8sapiapiserverinternalv1alpha1StorageVersion)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiapiserverinternalv1alpha1StorageVersionLens(response)
    }

    /**
     * delete a StorageVersion
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteInternalApiserverV1alpha1StorageVersion(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified StorageVersion
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readInternalApiserverV1alpha1StorageVersion(name: String, pretty: String? = null):
        StorageVersion {
        val iok8sapiapiserverinternalv1alpha1StorageVersionLens = Body.auto<StorageVersion>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiapiserverinternalv1alpha1StorageVersionLens(response)
    }

    /**
     * partially update the specified StorageVersion
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchInternalApiserverV1alpha1StorageVersion(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): StorageVersion {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiapiserverinternalv1alpha1StorageVersionLens = Body.auto<StorageVersion>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiapiserverinternalv1alpha1StorageVersionLens(response)
    }

    /**
     * replace the specified StorageVersion
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceInternalApiserverV1alpha1StorageVersion(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiapiserverinternalv1alpha1StorageVersion: StorageVersion
    ): StorageVersion {
        val iok8sapiapiserverinternalv1alpha1StorageVersionLens = Body.auto<StorageVersion>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}")
            .with(iok8sapiapiserverinternalv1alpha1StorageVersionLens of iok8sapiapiserverinternalv1alpha1StorageVersion)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiapiserverinternalv1alpha1StorageVersionLens(response)
    }

    /**
     * read status of the specified StorageVersion
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readInternalApiserverV1alpha1StorageVersionStatus(name: String, pretty: String? = null):
        StorageVersion {
        val iok8sapiapiserverinternalv1alpha1StorageVersionLens = Body.auto<StorageVersion>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiapiserverinternalv1alpha1StorageVersionLens(response)
    }

    /**
     * partially update status of the specified StorageVersion
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchInternalApiserverV1alpha1StorageVersionStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): StorageVersion {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiapiserverinternalv1alpha1StorageVersionLens = Body.auto<StorageVersion>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiapiserverinternalv1alpha1StorageVersionLens(response)
    }

    /**
     * replace status of the specified StorageVersion
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceInternalApiserverV1alpha1StorageVersionStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiapiserverinternalv1alpha1StorageVersion: StorageVersion
    ): StorageVersion {
        val iok8sapiapiserverinternalv1alpha1StorageVersionLens = Body.auto<StorageVersion>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status")
            .with(iok8sapiapiserverinternalv1alpha1StorageVersionLens of iok8sapiapiserverinternalv1alpha1StorageVersion)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiapiserverinternalv1alpha1StorageVersionLens(response)
    }

    /**
     * watch individual changes to a list of StorageVersion. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchInternalApiserverV1alpha1StorageVersionList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind StorageVersion. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchInternalApiserverV1alpha1StorageVersion(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getNetworkingAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getNetworkingV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of IngressClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteNetworkingV1CollectionIngressClass(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/networking.k8s.io/v1/ingressclasses")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind IngressClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listNetworkingV1IngressClass(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): IngressClassList {
        val iok8sapinetworkingv1IngressClassListLens = Body.auto<IngressClassList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/ingressclasses")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressClassListLens(response)
    }

    /**
     * create an IngressClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createNetworkingV1IngressClass(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1IngressClass: IngressClass
    ): IngressClass {
        val iok8sapinetworkingv1IngressClassLens = Body.auto<IngressClass>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/networking.k8s.io/v1/ingressclasses")
            .with(iok8sapinetworkingv1IngressClassLens of iok8sapinetworkingv1IngressClass)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressClassLens(response)
    }

    /**
     * delete an IngressClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteNetworkingV1IngressClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/networking.k8s.io/v1/ingressclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified IngressClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readNetworkingV1IngressClass(name: String, pretty: String? = null): IngressClass {
        val iok8sapinetworkingv1IngressClassLens = Body.auto<IngressClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/ingressclasses/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressClassLens(response)
    }

    /**
     * partially update the specified IngressClass
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchNetworkingV1IngressClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): IngressClass {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapinetworkingv1IngressClassLens = Body.auto<IngressClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/networking.k8s.io/v1/ingressclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressClassLens(response)
    }

    /**
     * replace the specified IngressClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceNetworkingV1IngressClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1IngressClass: IngressClass
    ): IngressClass {
        val iok8sapinetworkingv1IngressClassLens = Body.auto<IngressClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/networking.k8s.io/v1/ingressclasses/{name}")
            .with(iok8sapinetworkingv1IngressClassLens of iok8sapinetworkingv1IngressClass)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressClassLens(response)
    }

    /**
     * list or watch objects of kind Ingress
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listNetworkingV1IngressForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): IngressList {
        val iok8sapinetworkingv1IngressListLens = Body.auto<IngressList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/ingresses")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressListLens(response)
    }

    /**
     * delete collection of Ingress
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteNetworkingV1CollectionNamespacedIngress(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Ingress
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listNetworkingV1NamespacedIngress(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): IngressList {
        val iok8sapinetworkingv1IngressListLens = Body.auto<IngressList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressListLens(response)
    }

    /**
     * create an Ingress
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createNetworkingV1NamespacedIngress(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1Ingress: Ingress
    ): Ingress {
        val iok8sapinetworkingv1IngressLens = Body.auto<Ingress>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses")
            .with(iok8sapinetworkingv1IngressLens of iok8sapinetworkingv1Ingress)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressLens(response)
    }

    /**
     * delete an Ingress
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteNetworkingV1NamespacedIngress(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Ingress
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readNetworkingV1NamespacedIngress(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Ingress {
        val iok8sapinetworkingv1IngressLens = Body.auto<Ingress>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressLens(response)
    }

    /**
     * partially update the specified Ingress
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchNetworkingV1NamespacedIngress(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Ingress {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapinetworkingv1IngressLens = Body.auto<Ingress>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressLens(response)
    }

    /**
     * replace the specified Ingress
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceNetworkingV1NamespacedIngress(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1Ingress: Ingress
    ): Ingress {
        val iok8sapinetworkingv1IngressLens = Body.auto<Ingress>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}")
            .with(iok8sapinetworkingv1IngressLens of iok8sapinetworkingv1Ingress)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressLens(response)
    }

    /**
     * read status of the specified Ingress
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readNetworkingV1NamespacedIngressStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Ingress {
        val iok8sapinetworkingv1IngressLens = Body.auto<Ingress>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressLens(response)
    }

    /**
     * partially update status of the specified Ingress
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchNetworkingV1NamespacedIngressStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Ingress {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapinetworkingv1IngressLens = Body.auto<Ingress>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressLens(response)
    }

    /**
     * replace status of the specified Ingress
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceNetworkingV1NamespacedIngressStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1Ingress: Ingress
    ): Ingress {
        val iok8sapinetworkingv1IngressLens = Body.auto<Ingress>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status")
            .with(iok8sapinetworkingv1IngressLens of iok8sapinetworkingv1Ingress)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1IngressLens(response)
    }

    /**
     * delete collection of NetworkPolicy
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteNetworkingV1CollectionNamespacedNetworkPolicy(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listNetworkingV1NamespacedNetworkPolicy(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): NetworkPolicyList {
        val iok8sapinetworkingv1NetworkPolicyListLens = Body.auto<NetworkPolicyList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1NetworkPolicyListLens(response)
    }

    /**
     * create a NetworkPolicy
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createNetworkingV1NamespacedNetworkPolicy(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1NetworkPolicy: NetworkPolicy
    ): NetworkPolicy {
        val iok8sapinetworkingv1NetworkPolicyLens = Body.auto<NetworkPolicy>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies")
            .with(iok8sapinetworkingv1NetworkPolicyLens of iok8sapinetworkingv1NetworkPolicy)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1NetworkPolicyLens(response)
    }

    /**
     * delete a NetworkPolicy
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteNetworkingV1NamespacedNetworkPolicy(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified NetworkPolicy
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readNetworkingV1NamespacedNetworkPolicy(
        name: String,
        namespace: String,
        pretty: String? = null
    ): NetworkPolicy {
        val iok8sapinetworkingv1NetworkPolicyLens = Body.auto<NetworkPolicy>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1NetworkPolicyLens(response)
    }

    /**
     * partially update the specified NetworkPolicy
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchNetworkingV1NamespacedNetworkPolicy(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): NetworkPolicy {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapinetworkingv1NetworkPolicyLens = Body.auto<NetworkPolicy>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1NetworkPolicyLens(response)
    }

    /**
     * replace the specified NetworkPolicy
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceNetworkingV1NamespacedNetworkPolicy(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1NetworkPolicy: NetworkPolicy
    ): NetworkPolicy {
        val iok8sapinetworkingv1NetworkPolicyLens = Body.auto<NetworkPolicy>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}")
            .with(iok8sapinetworkingv1NetworkPolicyLens of iok8sapinetworkingv1NetworkPolicy)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1NetworkPolicyLens(response)
    }

    /**
     * read status of the specified NetworkPolicy
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readNetworkingV1NamespacedNetworkPolicyStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): NetworkPolicy {
        val iok8sapinetworkingv1NetworkPolicyLens = Body.auto<NetworkPolicy>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}/status")
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1NetworkPolicyLens(response)
    }

    /**
     * partially update status of the specified NetworkPolicy
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchNetworkingV1NamespacedNetworkPolicyStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): NetworkPolicy {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapinetworkingv1NetworkPolicyLens = Body.auto<NetworkPolicy>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}/status")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1NetworkPolicyLens(response)
    }

    /**
     * replace status of the specified NetworkPolicy
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceNetworkingV1NamespacedNetworkPolicyStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1NetworkPolicy: NetworkPolicy
    ): NetworkPolicy {
        val iok8sapinetworkingv1NetworkPolicyLens = Body.auto<NetworkPolicy>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}/status")
                .with(iok8sapinetworkingv1NetworkPolicyLens of iok8sapinetworkingv1NetworkPolicy)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1NetworkPolicyLens(response)
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listNetworkingV1NetworkPolicyForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): NetworkPolicyList {
        val iok8sapinetworkingv1NetworkPolicyListLens = Body.auto<NetworkPolicyList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/networkpolicies")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1NetworkPolicyListLens(response)
    }

    /**
     * watch individual changes to a list of IngressClass. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1IngressClassList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/watch/ingressclasses")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind IngressClass. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1IngressClass(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/watch/ingressclasses/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1IngressListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/watch/ingresses")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1NamespacedIngressList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Ingress. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1NamespacedIngress(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of NetworkPolicy. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1NamespacedNetworkPolicyList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind NetworkPolicy. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1NamespacedNetworkPolicy(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of NetworkPolicy. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1NetworkPolicyListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1/watch/networkpolicies")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getNetworkingV1alpha1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1alpha1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of ClusterCIDR
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteNetworkingV1alpha1CollectionClusterCIDR(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/networking.k8s.io/v1alpha1/clustercidrs")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ClusterCIDR
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listNetworkingV1alpha1ClusterCIDR(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ClusterCIDRList {
        val iok8sapinetworkingv1alpha1ClusterCIDRListLens = Body.auto<ClusterCIDRList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1alpha1/clustercidrs")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1alpha1ClusterCIDRListLens(response)
    }

    /**
     * create a ClusterCIDR
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createNetworkingV1alpha1ClusterCIDR(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1alpha1ClusterCIDR: ClusterCIDR
    ): ClusterCIDR {
        val iok8sapinetworkingv1alpha1ClusterCIDRLens = Body.auto<ClusterCIDR>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/networking.k8s.io/v1alpha1/clustercidrs")
            .with(iok8sapinetworkingv1alpha1ClusterCIDRLens of iok8sapinetworkingv1alpha1ClusterCIDR)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1alpha1ClusterCIDRLens(response)
    }

    /**
     * delete a ClusterCIDR
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteNetworkingV1alpha1ClusterCIDR(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/networking.k8s.io/v1alpha1/clustercidrs/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ClusterCIDR
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readNetworkingV1alpha1ClusterCIDR(name: String, pretty: String? = null): ClusterCIDR {
        val iok8sapinetworkingv1alpha1ClusterCIDRLens = Body.auto<ClusterCIDR>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1alpha1/clustercidrs/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1alpha1ClusterCIDRLens(response)
    }

    /**
     * partially update the specified ClusterCIDR
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchNetworkingV1alpha1ClusterCIDR(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ClusterCIDR {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapinetworkingv1alpha1ClusterCIDRLens = Body.auto<ClusterCIDR>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/networking.k8s.io/v1alpha1/clustercidrs/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1alpha1ClusterCIDRLens(response)
    }

    /**
     * replace the specified ClusterCIDR
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceNetworkingV1alpha1ClusterCIDR(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinetworkingv1alpha1ClusterCIDR: ClusterCIDR
    ): ClusterCIDR {
        val iok8sapinetworkingv1alpha1ClusterCIDRLens = Body.auto<ClusterCIDR>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/networking.k8s.io/v1alpha1/clustercidrs/{name}")
            .with(iok8sapinetworkingv1alpha1ClusterCIDRLens of iok8sapinetworkingv1alpha1ClusterCIDR)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinetworkingv1alpha1ClusterCIDRLens(response)
    }

    /**
     * watch individual changes to a list of ClusterCIDR. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1alpha1ClusterCIDRList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1alpha1/watch/clustercidrs")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ClusterCIDR. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNetworkingV1alpha1ClusterCIDR(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/networking.k8s.io/v1alpha1/watch/clustercidrs/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getNodeAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/node.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getNodeV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/node.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of RuntimeClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteNodeV1CollectionRuntimeClass(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/node.k8s.io/v1/runtimeclasses")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind RuntimeClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listNodeV1RuntimeClass(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): RuntimeClassList {
        val iok8sapinodev1RuntimeClassListLens = Body.auto<RuntimeClassList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/node.k8s.io/v1/runtimeclasses")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinodev1RuntimeClassListLens(response)
    }

    /**
     * create a RuntimeClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createNodeV1RuntimeClass(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinodev1RuntimeClass: RuntimeClass
    ): RuntimeClass {
        val iok8sapinodev1RuntimeClassLens = Body.auto<RuntimeClass>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/node.k8s.io/v1/runtimeclasses")
            .with(iok8sapinodev1RuntimeClassLens of iok8sapinodev1RuntimeClass)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinodev1RuntimeClassLens(response)
    }

    /**
     * delete a RuntimeClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteNodeV1RuntimeClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/node.k8s.io/v1/runtimeclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified RuntimeClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readNodeV1RuntimeClass(name: String, pretty: String? = null): RuntimeClass {
        val iok8sapinodev1RuntimeClassLens = Body.auto<RuntimeClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/node.k8s.io/v1/runtimeclasses/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinodev1RuntimeClassLens(response)
    }

    /**
     * partially update the specified RuntimeClass
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchNodeV1RuntimeClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): RuntimeClass {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapinodev1RuntimeClassLens = Body.auto<RuntimeClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/node.k8s.io/v1/runtimeclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinodev1RuntimeClassLens(response)
    }

    /**
     * replace the specified RuntimeClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceNodeV1RuntimeClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapinodev1RuntimeClass: RuntimeClass
    ): RuntimeClass {
        val iok8sapinodev1RuntimeClassLens = Body.auto<RuntimeClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/node.k8s.io/v1/runtimeclasses/{name}")
            .with(iok8sapinodev1RuntimeClassLens of iok8sapinodev1RuntimeClass)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapinodev1RuntimeClassLens(response)
    }

    /**
     * watch individual changes to a list of RuntimeClass. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNodeV1RuntimeClassList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/node.k8s.io/v1/watch/runtimeclasses")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind RuntimeClass. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchNodeV1RuntimeClass(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/node.k8s.io/v1/watch/runtimeclasses/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getPolicyAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/policy/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getPolicyV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/policy/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of PodDisruptionBudget
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deletePolicyV1CollectionNamespacedPodDisruptionBudget(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listPolicyV1NamespacedPodDisruptionBudget(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PodDisruptionBudgetList {
        val iok8sapipolicyv1PodDisruptionBudgetListLens = Body.auto<PodDisruptionBudgetList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1PodDisruptionBudgetListLens(response)
    }

    /**
     * create a PodDisruptionBudget
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createPolicyV1NamespacedPodDisruptionBudget(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapipolicyv1PodDisruptionBudget: PodDisruptionBudget
    ): PodDisruptionBudget {
        val iok8sapipolicyv1PodDisruptionBudgetLens = Body.auto<PodDisruptionBudget>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets")
            .with(iok8sapipolicyv1PodDisruptionBudgetLens of iok8sapipolicyv1PodDisruptionBudget)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1PodDisruptionBudgetLens(response)
    }

    /**
     * delete a PodDisruptionBudget
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deletePolicyV1NamespacedPodDisruptionBudget(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified PodDisruptionBudget
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readPolicyV1NamespacedPodDisruptionBudget(
        name: String,
        namespace: String,
        pretty: String? = null
    ): PodDisruptionBudget {
        val iok8sapipolicyv1PodDisruptionBudgetLens = Body.auto<PodDisruptionBudget>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1PodDisruptionBudgetLens(response)
    }

    /**
     * partially update the specified PodDisruptionBudget
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchPolicyV1NamespacedPodDisruptionBudget(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PodDisruptionBudget {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapipolicyv1PodDisruptionBudgetLens = Body.auto<PodDisruptionBudget>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1PodDisruptionBudgetLens(response)
    }

    /**
     * replace the specified PodDisruptionBudget
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replacePolicyV1NamespacedPodDisruptionBudget(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapipolicyv1PodDisruptionBudget: PodDisruptionBudget
    ): PodDisruptionBudget {
        val iok8sapipolicyv1PodDisruptionBudgetLens = Body.auto<PodDisruptionBudget>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}")
            .with(iok8sapipolicyv1PodDisruptionBudgetLens of iok8sapipolicyv1PodDisruptionBudget)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1PodDisruptionBudgetLens(response)
    }

    /**
     * read status of the specified PodDisruptionBudget
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readPolicyV1NamespacedPodDisruptionBudgetStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): PodDisruptionBudget {
        val iok8sapipolicyv1PodDisruptionBudgetLens = Body.auto<PodDisruptionBudget>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1PodDisruptionBudgetLens(response)
    }

    /**
     * partially update status of the specified PodDisruptionBudget
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchPolicyV1NamespacedPodDisruptionBudgetStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PodDisruptionBudget {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapipolicyv1PodDisruptionBudgetLens = Body.auto<PodDisruptionBudget>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1PodDisruptionBudgetLens(response)
    }

    /**
     * replace status of the specified PodDisruptionBudget
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replacePolicyV1NamespacedPodDisruptionBudgetStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapipolicyv1PodDisruptionBudget: PodDisruptionBudget
    ): PodDisruptionBudget {
        val iok8sapipolicyv1PodDisruptionBudgetLens = Body.auto<PodDisruptionBudget>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status")
            .with(iok8sapipolicyv1PodDisruptionBudgetLens of iok8sapipolicyv1PodDisruptionBudget)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1PodDisruptionBudgetLens(response)
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listPolicyV1PodDisruptionBudgetForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PodDisruptionBudgetList {
        val iok8sapipolicyv1PodDisruptionBudgetListLens = Body.auto<PodDisruptionBudgetList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/policy/v1/poddisruptionbudgets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapipolicyv1PodDisruptionBudgetListLens(response)
    }

    /**
     * watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchPolicyV1NamespacedPodDisruptionBudgetList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind PodDisruptionBudget. deprecated: use the 'watch' parameter
     * with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchPolicyV1NamespacedPodDisruptionBudget(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchPolicyV1PodDisruptionBudgetListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/policy/v1/watch/poddisruptionbudgets")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getRbacAuthorizationAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getRbacAuthorizationV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of ClusterRoleBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteRbacAuthorizationV1CollectionClusterRoleBinding(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ClusterRoleBinding
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listRbacAuthorizationV1ClusterRoleBinding(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ClusterRoleBindingList {
        val iok8sapirbacv1ClusterRoleBindingListLens = Body.auto<ClusterRoleBindingList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleBindingListLens(response)
    }

    /**
     * create a ClusterRoleBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createRbacAuthorizationV1ClusterRoleBinding(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapirbacv1ClusterRoleBinding: ClusterRoleBinding
    ): ClusterRoleBinding {
        val iok8sapirbacv1ClusterRoleBindingLens = Body.auto<ClusterRoleBinding>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings")
            .with(iok8sapirbacv1ClusterRoleBindingLens of iok8sapirbacv1ClusterRoleBinding)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleBindingLens(response)
    }

    /**
     * delete a ClusterRoleBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteRbacAuthorizationV1ClusterRoleBinding(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ClusterRoleBinding
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readRbacAuthorizationV1ClusterRoleBinding(name: String, pretty: String? = null):
        ClusterRoleBinding {
        val iok8sapirbacv1ClusterRoleBindingLens = Body.auto<ClusterRoleBinding>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleBindingLens(response)
    }

    /**
     * partially update the specified ClusterRoleBinding
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchRbacAuthorizationV1ClusterRoleBinding(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ClusterRoleBinding {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapirbacv1ClusterRoleBindingLens = Body.auto<ClusterRoleBinding>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleBindingLens(response)
    }

    /**
     * replace the specified ClusterRoleBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceRbacAuthorizationV1ClusterRoleBinding(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapirbacv1ClusterRoleBinding: ClusterRoleBinding
    ): ClusterRoleBinding {
        val iok8sapirbacv1ClusterRoleBindingLens = Body.auto<ClusterRoleBinding>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}")
            .with(iok8sapirbacv1ClusterRoleBindingLens of iok8sapirbacv1ClusterRoleBinding)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleBindingLens(response)
    }

    /**
     * delete collection of ClusterRole
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteRbacAuthorizationV1CollectionClusterRole(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/rbac.authorization.k8s.io/v1/clusterroles")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ClusterRole
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listRbacAuthorizationV1ClusterRole(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ClusterRoleList {
        val iok8sapirbacv1ClusterRoleListLens = Body.auto<ClusterRoleList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/clusterroles")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleListLens(response)
    }

    /**
     * create a ClusterRole
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createRbacAuthorizationV1ClusterRole(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapirbacv1ClusterRole: ClusterRole
    ): ClusterRole {
        val iok8sapirbacv1ClusterRoleLens = Body.auto<ClusterRole>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/rbac.authorization.k8s.io/v1/clusterroles")
            .with(iok8sapirbacv1ClusterRoleLens of iok8sapirbacv1ClusterRole)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleLens(response)
    }

    /**
     * delete a ClusterRole
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteRbacAuthorizationV1ClusterRole(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified ClusterRole
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readRbacAuthorizationV1ClusterRole(name: String, pretty: String? = null): ClusterRole {
        val iok8sapirbacv1ClusterRoleLens = Body.auto<ClusterRole>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleLens(response)
    }

    /**
     * partially update the specified ClusterRole
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchRbacAuthorizationV1ClusterRole(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ClusterRole {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapirbacv1ClusterRoleLens = Body.auto<ClusterRole>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleLens(response)
    }

    /**
     * replace the specified ClusterRole
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceRbacAuthorizationV1ClusterRole(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapirbacv1ClusterRole: ClusterRole
    ): ClusterRole {
        val iok8sapirbacv1ClusterRoleLens = Body.auto<ClusterRole>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}")
            .with(iok8sapirbacv1ClusterRoleLens of iok8sapirbacv1ClusterRole)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1ClusterRoleLens(response)
    }

    /**
     * delete collection of RoleBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteRbacAuthorizationV1CollectionNamespacedRoleBinding(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind RoleBinding
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listRbacAuthorizationV1NamespacedRoleBinding(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): RoleBindingList {
        val iok8sapirbacv1RoleBindingListLens = Body.auto<RoleBindingList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleBindingListLens(response)
    }

    /**
     * create a RoleBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createRbacAuthorizationV1NamespacedRoleBinding(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapirbacv1RoleBinding: RoleBinding
    ): RoleBinding {
        val iok8sapirbacv1RoleBindingLens = Body.auto<RoleBinding>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings")
            .with(iok8sapirbacv1RoleBindingLens of iok8sapirbacv1RoleBinding)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleBindingLens(response)
    }

    /**
     * delete a RoleBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteRbacAuthorizationV1NamespacedRoleBinding(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified RoleBinding
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readRbacAuthorizationV1NamespacedRoleBinding(
        name: String,
        namespace: String,
        pretty: String? = null
    ): RoleBinding {
        val iok8sapirbacv1RoleBindingLens = Body.auto<RoleBinding>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}")
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleBindingLens(response)
    }

    /**
     * partially update the specified RoleBinding
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchRbacAuthorizationV1NamespacedRoleBinding(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): RoleBinding {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapirbacv1RoleBindingLens = Body.auto<RoleBinding>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleBindingLens(response)
    }

    /**
     * replace the specified RoleBinding
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceRbacAuthorizationV1NamespacedRoleBinding(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapirbacv1RoleBinding: RoleBinding
    ): RoleBinding {
        val iok8sapirbacv1RoleBindingLens = Body.auto<RoleBinding>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}")
                .with(iok8sapirbacv1RoleBindingLens of iok8sapirbacv1RoleBinding)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleBindingLens(response)
    }

    /**
     * delete collection of Role
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteRbacAuthorizationV1CollectionNamespacedRole(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind Role
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listRbacAuthorizationV1NamespacedRole(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): RoleList {
        val iok8sapirbacv1RoleListLens = Body.auto<RoleList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleListLens(response)
    }

    /**
     * create a Role
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createRbacAuthorizationV1NamespacedRole(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapirbacv1Role: Role
    ): Role {
        val iok8sapirbacv1RoleLens = Body.auto<Role>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles")
            .with(iok8sapirbacv1RoleLens of iok8sapirbacv1Role)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleLens(response)
    }

    /**
     * delete a Role
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteRbacAuthorizationV1NamespacedRole(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified Role
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readRbacAuthorizationV1NamespacedRole(
        name: String,
        namespace: String,
        pretty: String? = null
    ): Role {
        val iok8sapirbacv1RoleLens = Body.auto<Role>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleLens(response)
    }

    /**
     * partially update the specified Role
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchRbacAuthorizationV1NamespacedRole(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): Role {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapirbacv1RoleLens = Body.auto<Role>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleLens(response)
    }

    /**
     * replace the specified Role
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceRbacAuthorizationV1NamespacedRole(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapirbacv1Role: Role
    ): Role {
        val iok8sapirbacv1RoleLens = Body.auto<Role>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}")
            .with(iok8sapirbacv1RoleLens of iok8sapirbacv1Role)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleLens(response)
    }

    /**
     * list or watch objects of kind RoleBinding
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listRbacAuthorizationV1RoleBindingForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): RoleBindingList {
        val iok8sapirbacv1RoleBindingListLens = Body.auto<RoleBindingList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/rolebindings")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleBindingListLens(response)
    }

    /**
     * list or watch objects of kind Role
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listRbacAuthorizationV1RoleForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): RoleList {
        val iok8sapirbacv1RoleListLens = Body.auto<RoleList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/roles")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapirbacv1RoleListLens(response)
    }

    /**
     * watch individual changes to a list of ClusterRoleBinding. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1ClusterRoleBindingList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ClusterRoleBinding. deprecated: use the 'watch' parameter
     * with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1ClusterRoleBinding(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ClusterRole. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1ClusterRoleList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/clusterroles")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ClusterRole. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1ClusterRole(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/clusterroles/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1NamespacedRoleBindingList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind RoleBinding. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1NamespacedRoleBinding(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1NamespacedRoleList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind Role. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1NamespacedRole(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1RoleBindingListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/rolebindings")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchRbacAuthorizationV1RoleListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/rbac.authorization.k8s.io/v1/watch/roles")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getResourceAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getResourceV1alpha1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of PodScheduling
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteResourceV1alpha1CollectionNamespacedPodScheduling(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind PodScheduling
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listResourceV1alpha1NamespacedPodScheduling(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PodSchedulingList {
        val iok8sapiresourcev1alpha1PodSchedulingListLens = Body.auto<PodSchedulingList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingListLens(response)
    }

    /**
     * create a PodScheduling
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createResourceV1alpha1NamespacedPodScheduling(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1PodScheduling: PodScheduling
    ): PodScheduling {
        val iok8sapiresourcev1alpha1PodSchedulingLens = Body.auto<PodScheduling>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings")
            .with(iok8sapiresourcev1alpha1PodSchedulingLens of iok8sapiresourcev1alpha1PodScheduling)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingLens(response)
    }

    /**
     * delete a PodScheduling
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteResourceV1alpha1NamespacedPodScheduling(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): PodScheduling {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapiresourcev1alpha1PodSchedulingLens = Body.auto<PodScheduling>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingLens(response)
    }

    /**
     * read the specified PodScheduling
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readResourceV1alpha1NamespacedPodScheduling(
        name: String,
        namespace: String,
        pretty: String? = null
    ): PodScheduling {
        val iok8sapiresourcev1alpha1PodSchedulingLens = Body.auto<PodScheduling>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingLens(response)
    }

    /**
     * partially update the specified PodScheduling
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchResourceV1alpha1NamespacedPodScheduling(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PodScheduling {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiresourcev1alpha1PodSchedulingLens = Body.auto<PodScheduling>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingLens(response)
    }

    /**
     * replace the specified PodScheduling
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceResourceV1alpha1NamespacedPodScheduling(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1PodScheduling: PodScheduling
    ): PodScheduling {
        val iok8sapiresourcev1alpha1PodSchedulingLens = Body.auto<PodScheduling>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings/{name}")
            .with(iok8sapiresourcev1alpha1PodSchedulingLens of iok8sapiresourcev1alpha1PodScheduling)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingLens(response)
    }

    /**
     * read status of the specified PodScheduling
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readResourceV1alpha1NamespacedPodSchedulingStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): PodScheduling {
        val iok8sapiresourcev1alpha1PodSchedulingLens = Body.auto<PodScheduling>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings/{name}/status")
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingLens(response)
    }

    /**
     * partially update status of the specified PodScheduling
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchResourceV1alpha1NamespacedPodSchedulingStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PodScheduling {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiresourcev1alpha1PodSchedulingLens = Body.auto<PodScheduling>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings/{name}/status")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingLens(response)
    }

    /**
     * replace status of the specified PodScheduling
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceResourceV1alpha1NamespacedPodSchedulingStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1PodScheduling: PodScheduling
    ): PodScheduling {
        val iok8sapiresourcev1alpha1PodSchedulingLens = Body.auto<PodScheduling>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/podschedulings/{name}/status")
                .with(iok8sapiresourcev1alpha1PodSchedulingLens of iok8sapiresourcev1alpha1PodScheduling)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingLens(response)
    }

    /**
     * delete collection of ResourceClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteResourceV1alpha1CollectionNamespacedResourceClaim(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ResourceClaim
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listResourceV1alpha1NamespacedResourceClaim(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ResourceClaimList {
        val iok8sapiresourcev1alpha1ResourceClaimListLens = Body.auto<ResourceClaimList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimListLens(response)
    }

    /**
     * create a ResourceClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createResourceV1alpha1NamespacedResourceClaim(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1ResourceClaim: ResourceClaim
    ): ResourceClaim {
        val iok8sapiresourcev1alpha1ResourceClaimLens = Body.auto<ResourceClaim>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims")
            .with(iok8sapiresourcev1alpha1ResourceClaimLens of iok8sapiresourcev1alpha1ResourceClaim)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimLens(response)
    }

    /**
     * delete a ResourceClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteResourceV1alpha1NamespacedResourceClaim(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): ResourceClaim {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapiresourcev1alpha1ResourceClaimLens = Body.auto<ResourceClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimLens(response)
    }

    /**
     * read the specified ResourceClaim
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readResourceV1alpha1NamespacedResourceClaim(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ResourceClaim {
        val iok8sapiresourcev1alpha1ResourceClaimLens = Body.auto<ResourceClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimLens(response)
    }

    /**
     * partially update the specified ResourceClaim
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchResourceV1alpha1NamespacedResourceClaim(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ResourceClaim {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiresourcev1alpha1ResourceClaimLens = Body.auto<ResourceClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimLens(response)
    }

    /**
     * replace the specified ResourceClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceResourceV1alpha1NamespacedResourceClaim(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1ResourceClaim: ResourceClaim
    ): ResourceClaim {
        val iok8sapiresourcev1alpha1ResourceClaimLens = Body.auto<ResourceClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims/{name}")
            .with(iok8sapiresourcev1alpha1ResourceClaimLens of iok8sapiresourcev1alpha1ResourceClaim)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimLens(response)
    }

    /**
     * read status of the specified ResourceClaim
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readResourceV1alpha1NamespacedResourceClaimStatus(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ResourceClaim {
        val iok8sapiresourcev1alpha1ResourceClaimLens = Body.auto<ResourceClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims/{name}/status")
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimLens(response)
    }

    /**
     * partially update status of the specified ResourceClaim
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchResourceV1alpha1NamespacedResourceClaimStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ResourceClaim {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiresourcev1alpha1ResourceClaimLens = Body.auto<ResourceClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims/{name}/status")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimLens(response)
    }

    /**
     * replace status of the specified ResourceClaim
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceResourceV1alpha1NamespacedResourceClaimStatus(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1ResourceClaim: ResourceClaim
    ): ResourceClaim {
        val iok8sapiresourcev1alpha1ResourceClaimLens = Body.auto<ResourceClaim>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaims/{name}/status")
                .with(iok8sapiresourcev1alpha1ResourceClaimLens of iok8sapiresourcev1alpha1ResourceClaim)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimLens(response)
    }

    /**
     * delete collection of ResourceClaimTemplate
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteResourceV1alpha1CollectionNamespacedResourceClaimTemplate(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq =
            Request(Method.DELETE, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaimtemplates")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(continueLens of `continue`)
                .with(dryRunLens of dryRun)
                .with(fieldSelectorLens of fieldSelector)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listResourceV1alpha1NamespacedResourceClaimTemplate(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ResourceClaimTemplateList {
        val iok8sapiresourcev1alpha1ResourceClaimTemplateListLens =
            Body.auto<ResourceClaimTemplateList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaimtemplates")
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimTemplateListLens(response)
    }

    /**
     * create a ResourceClaimTemplate
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createResourceV1alpha1NamespacedResourceClaimTemplate(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1ResourceClaimTemplate: ResourceClaimTemplate
    ): ResourceClaimTemplate {
        val iok8sapiresourcev1alpha1ResourceClaimTemplateLens =
            Body.auto<ResourceClaimTemplate>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.POST, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaimtemplates")
                .with(iok8sapiresourcev1alpha1ResourceClaimTemplateLens of iok8sapiresourcev1alpha1ResourceClaimTemplate)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimTemplateLens(response)
    }

    /**
     * delete a ResourceClaimTemplate
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteResourceV1alpha1NamespacedResourceClaimTemplate(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): ResourceClaimTemplate {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapiresourcev1alpha1ResourceClaimTemplateLens =
            Body.auto<ResourceClaimTemplate>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(
            Method.DELETE,
            "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaimtemplates/{name}"
        )
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimTemplateLens(response)
    }

    /**
     * read the specified ResourceClaimTemplate
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readResourceV1alpha1NamespacedResourceClaimTemplate(
        name: String,
        namespace: String,
        pretty: String? = null
    ): ResourceClaimTemplate {
        val iok8sapiresourcev1alpha1ResourceClaimTemplateLens =
            Body.auto<ResourceClaimTemplate>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaimtemplates/{name}")
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimTemplateLens(response)
    }

    /**
     * partially update the specified ResourceClaimTemplate
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchResourceV1alpha1NamespacedResourceClaimTemplate(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ResourceClaimTemplate {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiresourcev1alpha1ResourceClaimTemplateLens =
            Body.auto<ResourceClaimTemplate>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaimtemplates/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimTemplateLens(response)
    }

    /**
     * replace the specified ResourceClaimTemplate
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceResourceV1alpha1NamespacedResourceClaimTemplate(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1ResourceClaimTemplate: ResourceClaimTemplate
    ): ResourceClaimTemplate {
        val iok8sapiresourcev1alpha1ResourceClaimTemplateLens =
            Body.auto<ResourceClaimTemplate>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/resource.k8s.io/v1alpha1/namespaces/{namespace}/resourceclaimtemplates/{name}")
                .with(iok8sapiresourcev1alpha1ResourceClaimTemplateLens of iok8sapiresourcev1alpha1ResourceClaimTemplate)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimTemplateLens(response)
    }

    /**
     * list or watch objects of kind PodScheduling
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listResourceV1alpha1PodSchedulingForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PodSchedulingList {
        val iok8sapiresourcev1alpha1PodSchedulingListLens = Body.auto<PodSchedulingList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/podschedulings")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1PodSchedulingListLens(response)
    }

    /**
     * list or watch objects of kind ResourceClaim
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listResourceV1alpha1ResourceClaimForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ResourceClaimList {
        val iok8sapiresourcev1alpha1ResourceClaimListLens = Body.auto<ResourceClaimList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/resourceclaims")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimListLens(response)
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listResourceV1alpha1ResourceClaimTemplateForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ResourceClaimTemplateList {
        val iok8sapiresourcev1alpha1ResourceClaimTemplateListLens =
            Body.auto<ResourceClaimTemplateList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/resourceclaimtemplates")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClaimTemplateListLens(response)
    }

    /**
     * delete collection of ResourceClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteResourceV1alpha1CollectionResourceClass(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/resource.k8s.io/v1alpha1/resourceclasses")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind ResourceClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listResourceV1alpha1ResourceClass(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): ResourceClassList {
        val iok8sapiresourcev1alpha1ResourceClassListLens = Body.auto<ResourceClassList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/resourceclasses")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClassListLens(response)
    }

    /**
     * create a ResourceClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createResourceV1alpha1ResourceClass(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1ResourceClass: ResourceClass
    ): ResourceClass {
        val iok8sapiresourcev1alpha1ResourceClassLens = Body.auto<ResourceClass>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/resource.k8s.io/v1alpha1/resourceclasses")
            .with(iok8sapiresourcev1alpha1ResourceClassLens of iok8sapiresourcev1alpha1ResourceClass)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClassLens(response)
    }

    /**
     * delete a ResourceClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteResourceV1alpha1ResourceClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): ResourceClass {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapiresourcev1alpha1ResourceClassLens = Body.auto<ResourceClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/resource.k8s.io/v1alpha1/resourceclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClassLens(response)
    }

    /**
     * read the specified ResourceClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readResourceV1alpha1ResourceClass(name: String, pretty: String? = null): ResourceClass {
        val iok8sapiresourcev1alpha1ResourceClassLens = Body.auto<ResourceClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/resourceclasses/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClassLens(response)
    }

    /**
     * partially update the specified ResourceClass
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchResourceV1alpha1ResourceClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): ResourceClass {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapiresourcev1alpha1ResourceClassLens = Body.auto<ResourceClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/resource.k8s.io/v1alpha1/resourceclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClassLens(response)
    }

    /**
     * replace the specified ResourceClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceResourceV1alpha1ResourceClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapiresourcev1alpha1ResourceClass: ResourceClass
    ): ResourceClass {
        val iok8sapiresourcev1alpha1ResourceClassLens = Body.auto<ResourceClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/resource.k8s.io/v1alpha1/resourceclasses/{name}")
            .with(iok8sapiresourcev1alpha1ResourceClassLens of iok8sapiresourcev1alpha1ResourceClass)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapiresourcev1alpha1ResourceClassLens(response)
    }

    /**
     * watch individual changes to a list of PodScheduling. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1NamespacedPodSchedulingList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/namespaces/{namespace}/podschedulings")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind PodScheduling. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1NamespacedPodScheduling(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/namespaces/{namespace}/podschedulings/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ResourceClaim. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1NamespacedResourceClaimList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/namespaces/{namespace}/resourceclaims")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ResourceClaim. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1NamespacedResourceClaim(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/namespaces/{namespace}/resourceclaims/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ResourceClaimTemplate. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1NamespacedResourceClaimTemplateList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/namespaces/{namespace}/resourceclaimtemplates")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ResourceClaimTemplate. deprecated: use the 'watch' parameter
     * with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1NamespacedResourceClaimTemplate(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(
            Method.GET,
            "/apis/resource.k8s.io/v1alpha1/watch/namespaces/{namespace}/resourceclaimtemplates/{name}"
        )
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of PodScheduling. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1PodSchedulingListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/podschedulings")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ResourceClaim. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1ResourceClaimListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/resourceclaims")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ResourceClaimTemplate. deprecated: use the 'watch'
     * parameter with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1ResourceClaimTemplateListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/resourceclaimtemplates")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of ResourceClass. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1ResourceClassList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/resourceclasses")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind ResourceClass. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchResourceV1alpha1ResourceClass(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/resource.k8s.io/v1alpha1/watch/resourceclasses/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getSchedulingAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/scheduling.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getSchedulingV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/scheduling.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of PriorityClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteSchedulingV1CollectionPriorityClass(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/scheduling.k8s.io/v1/priorityclasses")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind PriorityClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listSchedulingV1PriorityClass(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): PriorityClassList {
        val iok8sapischedulingv1PriorityClassListLens = Body.auto<PriorityClassList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/scheduling.k8s.io/v1/priorityclasses")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapischedulingv1PriorityClassListLens(response)
    }

    /**
     * create a PriorityClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createSchedulingV1PriorityClass(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapischedulingv1PriorityClass: PriorityClass
    ): PriorityClass {
        val iok8sapischedulingv1PriorityClassLens = Body.auto<PriorityClass>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/scheduling.k8s.io/v1/priorityclasses")
            .with(iok8sapischedulingv1PriorityClassLens of iok8sapischedulingv1PriorityClass)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapischedulingv1PriorityClassLens(response)
    }

    /**
     * delete a PriorityClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteSchedulingV1PriorityClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/scheduling.k8s.io/v1/priorityclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified PriorityClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readSchedulingV1PriorityClass(name: String, pretty: String? = null): PriorityClass {
        val iok8sapischedulingv1PriorityClassLens = Body.auto<PriorityClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/scheduling.k8s.io/v1/priorityclasses/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapischedulingv1PriorityClassLens(response)
    }

    /**
     * partially update the specified PriorityClass
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchSchedulingV1PriorityClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): PriorityClass {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapischedulingv1PriorityClassLens = Body.auto<PriorityClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/scheduling.k8s.io/v1/priorityclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapischedulingv1PriorityClassLens(response)
    }

    /**
     * replace the specified PriorityClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceSchedulingV1PriorityClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapischedulingv1PriorityClass: PriorityClass
    ): PriorityClass {
        val iok8sapischedulingv1PriorityClassLens = Body.auto<PriorityClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/scheduling.k8s.io/v1/priorityclasses/{name}")
            .with(iok8sapischedulingv1PriorityClassLens of iok8sapischedulingv1PriorityClass)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapischedulingv1PriorityClassLens(response)
    }

    /**
     * watch individual changes to a list of PriorityClass. deprecated: use the 'watch' parameter with
     * a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchSchedulingV1PriorityClassList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/scheduling.k8s.io/v1/watch/priorityclasses")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind PriorityClass. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchSchedulingV1PriorityClass(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/scheduling.k8s.io/v1/watch/priorityclasses/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get information of a group
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getStorageAPIGroup(): APIGroup {
        val iok8sapimachinerypkgapismetav1APIGroupLens = Body.auto<APIGroup>().toLens()
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIGroupLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getStorageV1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * delete collection of CSIDriver
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteStorageV1CollectionCSIDriver(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1/csidrivers")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind CSIDriver
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listStorageV1CSIDriver(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): CSIDriverList {
        val iok8sapistoragev1CSIDriverListLens = Body.auto<CSIDriverList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/csidrivers")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIDriverListLens(response)
    }

    /**
     * create a CSIDriver
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createStorageV1CSIDriver(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1CSIDriver: CSIDriver
    ): CSIDriver {
        val iok8sapistoragev1CSIDriverLens = Body.auto<CSIDriver>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/storage.k8s.io/v1/csidrivers")
            .with(iok8sapistoragev1CSIDriverLens of iok8sapistoragev1CSIDriver)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIDriverLens(response)
    }

    /**
     * delete a CSIDriver
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteStorageV1CSIDriver(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): CSIDriver {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapistoragev1CSIDriverLens = Body.auto<CSIDriver>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1/csidrivers/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIDriverLens(response)
    }

    /**
     * read the specified CSIDriver
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readStorageV1CSIDriver(name: String, pretty: String? = null): CSIDriver {
        val iok8sapistoragev1CSIDriverLens = Body.auto<CSIDriver>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/csidrivers/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIDriverLens(response)
    }

    /**
     * partially update the specified CSIDriver
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchStorageV1CSIDriver(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CSIDriver {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapistoragev1CSIDriverLens = Body.auto<CSIDriver>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/storage.k8s.io/v1/csidrivers/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIDriverLens(response)
    }

    /**
     * replace the specified CSIDriver
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceStorageV1CSIDriver(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1CSIDriver: CSIDriver
    ): CSIDriver {
        val iok8sapistoragev1CSIDriverLens = Body.auto<CSIDriver>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/storage.k8s.io/v1/csidrivers/{name}")
            .with(iok8sapistoragev1CSIDriverLens of iok8sapistoragev1CSIDriver)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIDriverLens(response)
    }

    /**
     * delete collection of CSINode
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteStorageV1CollectionCSINode(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1/csinodes")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind CSINode
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listStorageV1CSINode(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): CSINodeList {
        val iok8sapistoragev1CSINodeListLens = Body.auto<CSINodeList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/csinodes")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSINodeListLens(response)
    }

    /**
     * create a CSINode
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createStorageV1CSINode(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1CSINode: CSINode
    ): CSINode {
        val iok8sapistoragev1CSINodeLens = Body.auto<CSINode>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/storage.k8s.io/v1/csinodes")
            .with(iok8sapistoragev1CSINodeLens of iok8sapistoragev1CSINode)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSINodeLens(response)
    }

    /**
     * delete a CSINode
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteStorageV1CSINode(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): CSINode {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapistoragev1CSINodeLens = Body.auto<CSINode>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1/csinodes/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSINodeLens(response)
    }

    /**
     * read the specified CSINode
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readStorageV1CSINode(name: String, pretty: String? = null): CSINode {
        val iok8sapistoragev1CSINodeLens = Body.auto<CSINode>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/csinodes/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSINodeLens(response)
    }

    /**
     * partially update the specified CSINode
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchStorageV1CSINode(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CSINode {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapistoragev1CSINodeLens = Body.auto<CSINode>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/storage.k8s.io/v1/csinodes/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSINodeLens(response)
    }

    /**
     * replace the specified CSINode
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceStorageV1CSINode(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1CSINode: CSINode
    ): CSINode {
        val iok8sapistoragev1CSINodeLens = Body.auto<CSINode>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/storage.k8s.io/v1/csinodes/{name}")
            .with(iok8sapistoragev1CSINodeLens of iok8sapistoragev1CSINode)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSINodeLens(response)
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listStorageV1CSIStorageCapacityForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): CSIStorageCapacityList {
        val iok8sapistoragev1CSIStorageCapacityListLens = Body.auto<CSIStorageCapacityList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/csistoragecapacities")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIStorageCapacityListLens(response)
    }

    /**
     * delete collection of CSIStorageCapacity
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteStorageV1CollectionNamespacedCSIStorageCapacity(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listStorageV1NamespacedCSIStorageCapacity(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): CSIStorageCapacityList {
        val iok8sapistoragev1CSIStorageCapacityListLens = Body.auto<CSIStorageCapacityList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIStorageCapacityListLens(response)
    }

    /**
     * create a CSIStorageCapacity
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createStorageV1NamespacedCSIStorageCapacity(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1CSIStorageCapacity: CSIStorageCapacity
    ): CSIStorageCapacity {
        val iok8sapistoragev1CSIStorageCapacityLens = Body.auto<CSIStorageCapacity>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities")
            .with(iok8sapistoragev1CSIStorageCapacityLens of iok8sapistoragev1CSIStorageCapacity)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIStorageCapacityLens(response)
    }

    /**
     * delete a CSIStorageCapacity
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteStorageV1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified CSIStorageCapacity
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readStorageV1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        pretty: String? = null
    ): CSIStorageCapacity {
        val iok8sapistoragev1CSIStorageCapacityLens = Body.auto<CSIStorageCapacity>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities/{name}")
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIStorageCapacityLens(response)
    }

    /**
     * partially update the specified CSIStorageCapacity
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchStorageV1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): CSIStorageCapacity {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapistoragev1CSIStorageCapacityLens = Body.auto<CSIStorageCapacity>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIStorageCapacityLens(response)
    }

    /**
     * replace the specified CSIStorageCapacity
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceStorageV1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1CSIStorageCapacity: CSIStorageCapacity
    ): CSIStorageCapacity {
        val iok8sapistoragev1CSIStorageCapacityLens = Body.auto<CSIStorageCapacity>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities/{name}")
            .with(iok8sapistoragev1CSIStorageCapacityLens of iok8sapistoragev1CSIStorageCapacity)
            .with(nameLens of name)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1CSIStorageCapacityLens(response)
    }

    /**
     * delete collection of StorageClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteStorageV1CollectionStorageClass(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1/storageclasses")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind StorageClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listStorageV1StorageClass(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): StorageClassList {
        val iok8sapistoragev1StorageClassListLens = Body.auto<StorageClassList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/storageclasses")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1StorageClassListLens(response)
    }

    /**
     * create a StorageClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createStorageV1StorageClass(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1StorageClass: StorageClass
    ): StorageClass {
        val iok8sapistoragev1StorageClassLens = Body.auto<StorageClass>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/storage.k8s.io/v1/storageclasses")
            .with(iok8sapistoragev1StorageClassLens of iok8sapistoragev1StorageClass)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1StorageClassLens(response)
    }

    /**
     * delete a StorageClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteStorageV1StorageClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): StorageClass {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapistoragev1StorageClassLens = Body.auto<StorageClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1/storageclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1StorageClassLens(response)
    }

    /**
     * read the specified StorageClass
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readStorageV1StorageClass(name: String, pretty: String? = null): StorageClass {
        val iok8sapistoragev1StorageClassLens = Body.auto<StorageClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/storageclasses/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1StorageClassLens(response)
    }

    /**
     * partially update the specified StorageClass
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchStorageV1StorageClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): StorageClass {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapistoragev1StorageClassLens = Body.auto<StorageClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/storage.k8s.io/v1/storageclasses/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1StorageClassLens(response)
    }

    /**
     * replace the specified StorageClass
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceStorageV1StorageClass(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1StorageClass: StorageClass
    ): StorageClass {
        val iok8sapistoragev1StorageClassLens = Body.auto<StorageClass>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/storage.k8s.io/v1/storageclasses/{name}")
            .with(iok8sapistoragev1StorageClassLens of iok8sapistoragev1StorageClass)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1StorageClassLens(response)
    }

    /**
     * delete collection of VolumeAttachment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteStorageV1CollectionVolumeAttachment(
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1/volumeattachments")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind VolumeAttachment
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listStorageV1VolumeAttachment(
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): VolumeAttachmentList {
        val iok8sapistoragev1VolumeAttachmentListLens = Body.auto<VolumeAttachmentList>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/volumeattachments")
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1VolumeAttachmentListLens(response)
    }

    /**
     * create a VolumeAttachment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createStorageV1VolumeAttachment(
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1VolumeAttachment: VolumeAttachment
    ): VolumeAttachment {
        val iok8sapistoragev1VolumeAttachmentLens = Body.auto<VolumeAttachment>().toLens()
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/storage.k8s.io/v1/volumeattachments")
            .with(iok8sapistoragev1VolumeAttachmentLens of iok8sapistoragev1VolumeAttachment)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1VolumeAttachmentLens(response)
    }

    /**
     * delete a VolumeAttachment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteStorageV1VolumeAttachment(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): VolumeAttachment {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapistoragev1VolumeAttachmentLens = Body.auto<VolumeAttachment>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1/volumeattachments/{name}")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1VolumeAttachmentLens(response)
    }

    /**
     * read the specified VolumeAttachment
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readStorageV1VolumeAttachment(name: String, pretty: String? = null): VolumeAttachment {
        val iok8sapistoragev1VolumeAttachmentLens = Body.auto<VolumeAttachment>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/volumeattachments/{name}")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1VolumeAttachmentLens(response)
    }

    /**
     * partially update the specified VolumeAttachment
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchStorageV1VolumeAttachment(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): VolumeAttachment {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapistoragev1VolumeAttachmentLens = Body.auto<VolumeAttachment>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/storage.k8s.io/v1/volumeattachments/{name}")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1VolumeAttachmentLens(response)
    }

    /**
     * replace the specified VolumeAttachment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceStorageV1VolumeAttachment(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1VolumeAttachment: VolumeAttachment
    ): VolumeAttachment {
        val iok8sapistoragev1VolumeAttachmentLens = Body.auto<VolumeAttachment>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/storage.k8s.io/v1/volumeattachments/{name}")
            .with(iok8sapistoragev1VolumeAttachmentLens of iok8sapistoragev1VolumeAttachment)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1VolumeAttachmentLens(response)
    }

    /**
     * read status of the specified VolumeAttachment
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readStorageV1VolumeAttachmentStatus(name: String, pretty: String? = null):
        VolumeAttachment {
        val iok8sapistoragev1VolumeAttachmentLens = Body.auto<VolumeAttachment>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/volumeattachments/{name}/status")
            .with(nameLens of name)
            .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1VolumeAttachmentLens(response)
    }

    /**
     * partially update status of the specified VolumeAttachment
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchStorageV1VolumeAttachmentStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): VolumeAttachment {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapistoragev1VolumeAttachmentLens = Body.auto<VolumeAttachment>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq = Request(Method.PATCH, "/apis/storage.k8s.io/v1/volumeattachments/{name}/status")
            .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
            .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1VolumeAttachmentLens(response)
    }

    /**
     * replace status of the specified VolumeAttachment
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceStorageV1VolumeAttachmentStatus(
        name: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1VolumeAttachment: VolumeAttachment
    ): VolumeAttachment {
        val iok8sapistoragev1VolumeAttachmentLens = Body.auto<VolumeAttachment>().toLens()
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.PUT, "/apis/storage.k8s.io/v1/volumeattachments/{name}/status")
            .with(iok8sapistoragev1VolumeAttachmentLens of iok8sapistoragev1VolumeAttachment)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1VolumeAttachmentLens(response)
    }

    /**
     * watch individual changes to a list of CSIDriver. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1CSIDriverList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/csidrivers")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind CSIDriver. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1CSIDriver(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/csidrivers/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of CSINode. deprecated: use the 'watch' parameter with a list
     * operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1CSINodeList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/csinodes")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind CSINode. deprecated: use the 'watch' parameter with a list
     * operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1CSINode(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/csinodes/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1CSIStorageCapacityListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/csistoragecapacities")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1NamespacedCSIStorageCapacityList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/namespaces/{namespace}/csistoragecapacities")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind CSIStorageCapacity. deprecated: use the 'watch' parameter
     * with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/storage.k8s.io/v1/watch/namespaces/{namespace}/csistoragecapacities/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of StorageClass. deprecated: use the 'watch' parameter with a
     * list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1StorageClassList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/storageclasses")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind StorageClass. deprecated: use the 'watch' parameter with a
     * list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1StorageClass(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/storageclasses/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of VolumeAttachment. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1VolumeAttachmentList(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/volumeattachments")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind VolumeAttachment. deprecated: use the 'watch' parameter with
     * a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1VolumeAttachment(
        name: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1/watch/volumeattachments/{name}")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(nameLens of name)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * get available resources
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getStorageV1beta1APIResources(): APIResourceList {
        val iok8sapimachinerypkgapismetav1APIResourceListLens = Body.auto<APIResourceList>().toLens()
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1beta1/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1APIResourceListLens(response)
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listStorageV1beta1CSIStorageCapacityForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacityList {
        val iok8sapistoragev1beta1CSIStorageCapacityListLens =
            Body.auto<http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacityList>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1beta1/csistoragecapacities")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1beta1CSIStorageCapacityListLens(response)
    }

    /**
     * delete collection of CSIStorageCapacity
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun deleteStorageV1beta1CollectionNamespacedCSIStorageCapacity(
        namespace: String,
        pretty: String? = null,
        `continue`: String? = null,
        dryRun: String? = null,
        fieldSelector: String? = null,
        gracePeriodSeconds: Int? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val continueLens = Query.string().optional("continue")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val httpReq = Request(Method.DELETE, "/apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities")
            .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(continueLens of `continue`)
            .with(dryRunLens of dryRun)
            .with(fieldSelectorLens of fieldSelector)
            .with(gracePeriodSecondsLens of gracePeriodSeconds)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(orphanDependentsLens of orphanDependents)
            .with(propagationPolicyLens of propagationPolicy)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun listStorageV1beta1NamespacedCSIStorageCapacity(
        namespace: String,
        pretty: String? = null,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacityList {
        val iok8sapistoragev1beta1CSIStorageCapacityListLens =
            Body.auto<http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacityList>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities")
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1beta1CSIStorageCapacityListLens(response)
    }

    /**
     * create a CSIStorageCapacity
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun createStorageV1beta1NamespacedCSIStorageCapacity(
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1beta1CSIStorageCapacity: http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity
    ): http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity {
        val iok8sapistoragev1beta1CSIStorageCapacityLens =
            Body.auto<http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity>().toLens()
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq = Request(Method.POST, "/apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities")
            .with(iok8sapistoragev1beta1CSIStorageCapacityLens of iok8sapistoragev1beta1CSIStorageCapacity)
            .with(namespaceLens of namespace)
            .with(prettyLens of pretty)
            .with(dryRunLens of dryRun)
            .with(fieldManagerLens of fieldManager)
            .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1beta1CSIStorageCapacityLens(response)
    }

    /**
     * delete a CSIStorageCapacity
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		202 Accepted
     * 		401 Unauthorized
     */
    fun deleteStorageV1beta1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        gracePeriodSeconds: Int? = null,
        orphanDependents: Boolean? = null,
        propagationPolicy: String? = null,
        iok8sapimachinerypkgapismetav1DeleteOptions: DeleteOptions
    ): Status {
        val iok8sapimachinerypkgapismetav1DeleteOptionsLens = Body.auto<DeleteOptions>().toLens()
        val iok8sapimachinerypkgapismetav1StatusLens = Body.auto<Status>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val gracePeriodSecondsLens = Query.int().optional("gracePeriodSeconds")
        val orphanDependentsLens = Query.boolean().optional("orphanDependents")
        val propagationPolicyLens = Query.string().optional("propagationPolicy")
        val httpReq =
            Request(Method.DELETE, "/apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}")
                .with(iok8sapimachinerypkgapismetav1DeleteOptionsLens of iok8sapimachinerypkgapismetav1DeleteOptions)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(gracePeriodSecondsLens of gracePeriodSeconds)
                .with(orphanDependentsLens of orphanDependents)
                .with(propagationPolicyLens of propagationPolicy)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1StatusLens(response)
    }

    /**
     * read the specified CSIStorageCapacity
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun readStorageV1beta1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        pretty: String? = null
    ): http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity {
        val iok8sapistoragev1beta1CSIStorageCapacityLens =
            Body.auto<http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val httpReq =
            Request(Method.GET, "/apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}")
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1beta1CSIStorageCapacityLens(response)
    }

    /**
     * partially update the specified CSIStorageCapacity
     * Request:
     * 	application/json-patch+json
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun patchStorageV1beta1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        force: Boolean? = null,
        iok8sapimachinerypkgapismetav1Patch: Patch
    ): http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity {
        val iok8sapimachinerypkgapismetav1PatchLens = Body.auto<Patch>().toLens()
        val iok8sapistoragev1beta1CSIStorageCapacityLens =
            Body.auto<http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val forceLens = Query.boolean().optional("force")
        val httpReq =
            Request(Method.PATCH, "/apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}")
                .with(iok8sapimachinerypkgapismetav1PatchLens of iok8sapimachinerypkgapismetav1Patch)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
                .with(forceLens of force)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1beta1CSIStorageCapacityLens(response)
    }

    /**
     * replace the specified CSIStorageCapacity
     * Request:
     * 	* / *
     * Response:
     * 	application/json
     * 		200 OK
     * 		201 Created
     * 		401 Unauthorized
     */
    fun replaceStorageV1beta1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        pretty: String? = null,
        dryRun: String? = null,
        fieldManager: String? = null,
        fieldValidation: String? = null,
        iok8sapistoragev1beta1CSIStorageCapacity: http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity
    ): http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity {
        val iok8sapistoragev1beta1CSIStorageCapacityLens =
            Body.auto<http4k.k8s.model.io.k8s.api.storage.v1beta1.CSIStorageCapacity>().toLens()
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val dryRunLens = Query.string().optional("dryRun")
        val fieldManagerLens = Query.string().optional("fieldManager")
        val fieldValidationLens = Query.string().optional("fieldValidation")
        val httpReq =
            Request(Method.PUT, "/apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}")
                .with(iok8sapistoragev1beta1CSIStorageCapacityLens of iok8sapistoragev1beta1CSIStorageCapacity)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(dryRunLens of dryRun)
                .with(fieldManagerLens of fieldManager)
                .with(fieldValidationLens of fieldValidation)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapistoragev1beta1CSIStorageCapacityLens(response)
    }

    /**
     * watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1beta1CSIStorageCapacityListForAllNamespaces(
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq = Request(Method.GET, "/apis/storage.k8s.io/v1beta1/watch/csistoragecapacities")
            .with(allowWatchBookmarksLens of allowWatchBookmarks)
            .with(continueLens of `continue`)
            .with(fieldSelectorLens of fieldSelector)
            .with(labelSelectorLens of labelSelector)
            .with(limitLens of limit)
            .with(prettyLens of pretty)
            .with(resourceVersionLens of resourceVersion)
            .with(resourceVersionMatchLens of resourceVersionMatch)
            .with(timeoutSecondsLens of timeoutSeconds)
            .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter
     * with a list operation instead.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1beta1NamespacedCSIStorageCapacityList(
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * watch changes to an object of kind CSIStorageCapacity. deprecated: use the 'watch' parameter
     * with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun watchStorageV1beta1NamespacedCSIStorageCapacity(
        name: String,
        namespace: String,
        allowWatchBookmarks: Boolean? = null,
        `continue`: String? = null,
        fieldSelector: String? = null,
        labelSelector: String? = null,
        limit: Int? = null,
        pretty: String? = null,
        resourceVersion: String? = null,
        resourceVersionMatch: String? = null,
        timeoutSeconds: Int? = null,
        watch: Boolean? = null
    ): WatchEvent {
        val iok8sapimachinerypkgapismetav1WatchEventLens = Body.auto<WatchEvent>().toLens()
        val allowWatchBookmarksLens = Query.boolean().optional("allowWatchBookmarks")
        val continueLens = Query.string().optional("continue")
        val fieldSelectorLens = Query.string().optional("fieldSelector")
        val labelSelectorLens = Query.string().optional("labelSelector")
        val limitLens = Query.int().optional("limit")
        val nameLens = Path.string().of("name")
        val namespaceLens = Path.string().of("namespace")
        val prettyLens = Query.string().optional("pretty")
        val resourceVersionLens = Query.string().optional("resourceVersion")
        val resourceVersionMatchLens = Query.string().optional("resourceVersionMatch")
        val timeoutSecondsLens = Query.int().optional("timeoutSeconds")
        val watchLens = Query.boolean().optional("watch")
        val httpReq =
            Request(Method.GET, "/apis/storage.k8s.io/v1beta1/watch/namespaces/{namespace}/csistoragecapacities/{name}")
                .with(allowWatchBookmarksLens of allowWatchBookmarks)
                .with(continueLens of `continue`)
                .with(fieldSelectorLens of fieldSelector)
                .with(labelSelectorLens of labelSelector)
                .with(limitLens of limit)
                .with(nameLens of name)
                .with(namespaceLens of namespace)
                .with(prettyLens of pretty)
                .with(resourceVersionLens of resourceVersion)
                .with(resourceVersionMatchLens of resourceVersionMatch)
                .with(timeoutSecondsLens of timeoutSeconds)
                .with(watchLens of watch)
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgapismetav1WatchEventLens(response)
    }

    /**
     * Response:
     * 	application/json
     * 		401 Unauthorized
     */
    fun logFileListHandler() {
        val httpReq = Request(Method.GET, "/logs/")
        val response = bearerToken.then(httpHandler)(httpReq)

        response
    }

    /**
     * Response:
     * 	application/json
     * 		401 Unauthorized
     */
    fun logFileHandler(logpath: String) {
        val logpathLens = Path.string().of("logpath")
        val httpReq = Request(Method.GET, "/logs/{logpath}")
            .with(logpathLens of logpath)
        val response = bearerToken.then(httpHandler)(httpReq)

        response
    }

    /**
     * get service account issuer OpenID JSON Web Key Set (contains public token verification keys)
     * Response:
     * 	application/jwk-set+json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getServiceAccountIssuerOpenIDKeyset(): String {
        val getServiceAccountIssuerOpenIDKeysetJwksetjsonResponse200Lens = Body.auto<String>().toLens()
        val httpReq = Request(Method.GET, "/openid/v1/jwks/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return getServiceAccountIssuerOpenIDKeysetJwksetjsonResponse200Lens(response)
    }

    /**
     * get the code version
     * Response:
     * 	application/json
     * 		200 OK
     * 		401 Unauthorized
     */
    fun getCodeVersion(): Info {
        val iok8sapimachinerypkgversionInfoLens = Body.auto<Info>().toLens()
        val httpReq = Request(Method.GET, "/version/")
        val response = bearerToken.then(httpHandler)(httpReq)
        return iok8sapimachinerypkgversionInfoLens(response)
    }
}
